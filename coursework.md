<p align="center">Министерство образования, науки и молодежной политики Республики Коми</p>

<p align="center">ГПОУ "Сыктывкарский политехнический техникум"</p>






<p align="center">Курсовая работа</p>



<p align="center">тема: База данных для контроля успеваемости школьников</p>















<p align="right"> выполнил </p>

<p align="right">студент 4 курса </p>

<p align="right">414 группы </p>

<p align="right">Попов Владислав Александрович</p>



<p align="right">проверил</p>

<p align="right">Пунгин И.В.</p>

<p align="right">дата проверки: ______________</p>










<p align="center">Сыктывкар, 2025</p>






# Задание на курсовую работу по МДК 11.01 "Технология разработки и защиты баз данных"

Специальность: <ins> 09.02.07 "Информационные системы и программирование"  </ins>

Тема курсовой работы:База данных для контроля успеваемости школьников

Срок представления работы к защите: <ins> 15 марта 2025 года. </ins>

Перечень подлежащих разработке вопросов:

1. Анализ предметной области. Постановка задачи.

    1.1. Описание предметной области и функции решаемых задач.

    1.2. Перечень входных данных.

    1.3. Перечень выходных данных

    1.4. Ограничения предметной области (если таковые имеются).

    1.5. Взаимодействие с другими программами.

3. Инфологическая (концептуальная) модель базы данных.

    2.1. Выделение информационных объектов.

    2.2. Определение атрибутов объектов.

    2.3. Определение отношений и мощности отношений между объектами.

    2.4. Построение концептуальной модели.

4. Логическая структура БД.

5. Физическая структура базы данных.

6. Реализация проекта в среде конкретной СУБД.

    6.1. Создание таблиц и индексов.

    6.2. Создание представлений и функций.

    5.3. Разработка интерфейса.

    5.4. Назначение прав доступа.

    5.5. Разработка стратегии резервного копирования базы данных.


Руководитель работы __________________ <ins> И. В. Пунгин </ins>

Задание принял к исполнению _______________________________ <ins> В. А. Попов </ins>




## <a id="content">Содержание</a>

1. [Введение](#introduction)
    - [Цель работы](#target)
    - [Задачи работы](#tasks)
2. [Основная часть](#main)
    - [Анализ предметной области. Постановка задачи](#analysis)
    - [Инфологическая (концептуальная) модель базы данных](#infological_model)
    - [Логическая структура БД](#logical_structure)
    - [Физическая структура базы данных](#physical_structure)
    - [Реализация проекта в среде конкретной СУБД](#project_realization)
3. [Заключение](#conclusion)
4. [Список использованных информационных источников](#literature)
5. [Приложения](#applications)


   
## <a id="introduction">Введение</a>

В современном образовательном процессе контроль успеваемости школьников является важным аспектом, влияющим на их академическую и профессиональную траекторию. Эффективное управление данными о успеваемости становится необходимостью, что обуславливает актуальность разработки базы данных (БД) для контроля успеваемости. Эта система должна обеспечивать удобный доступ к информации для учителей, администраторов и учеников, включая данные о классах, учениках, предметах, оценках и учителях.

Внедрение базы данных позволит автоматизировать процессы учета успеваемости, сократив время на выполнение рутинных задач и снизив вероятность ошибок. Ключевой задачей разработки БД является создание интуитивно понятного интерфейса для ввода, редактирования данных и генерации отчетов. Система должна обрабатывать запросы различной сложности и обеспечивать безопасность данных, включая механизмы защиты от несанкционированного доступа.

Реализация данного проекта создаст эффективную систему, способную хранить и анализировать данные, что позволит образовательным учреждениям улучшить качество обучения и повысить уровень успеваемости учащихся. Таким образом, курсовая работа направлена на разработку базы данных для контроля успеваемости школьников, отвечающей современным требованиям и способствующей оптимизации учебного процесса.


#### <a id="target">Цель работы</a>

Целью данной курсовой работы является разработка базы данных для контроля успеваемости школьников, которая позволит эффективно управлять информацией о студентах и их оценках, а также обеспечить доступ к этой информации для различных пользователей. В рамках работы предполагается:
1. Создание структуры базы данных: Разработать схему базы данных, произвести анализ и уточнение структуры, чтобы обеспечить целостность и согласованность данных. Важно, чтобы каждая таблица адекватно отражала сущности предметной области и их взаимосвязи.
2. Реализация функционала для ввода и обновления данных: Разработка функций для добавления и изменения оценок, а также для управления данными о студентах, учителях и предметах. Это позволит пользователям (учителям и администраторам) легко вводить новые данные, обновлять существующие записи и поддерживать актуальность информации.
3. Создание представлений и запросов для анализа успеваемости: Реализация представлений, которые будут агрегировать данные о успеваемости учеников по предметам и классам. Это позволит учителям и администраторам быстро получать информацию о текущем уровне успеваемости каждого ученика, а также оценивать общие результаты по классу и предмету.
4. Обеспечение безопасности и управления доступом: Разработка системы прав доступа, которая будет ограничивать возможности пользователей в зависимости от их ролей (учитель, администратор). Это необходимо для защиты конфиденциальной информации о студентах и обеспечения целостности данных.
5. Анализ полученных данных: Проведение анализа успеваемости учеников с использованием созданной базы данных. Это позволит выявить тенденции, проблемы и возможности для улучшения учебного процесса, а также поможет в принятии обоснованных решений по дальнейшему обучению.
6. Документирование процесса разработки: Подготовка технической и эксплуатационной документации, включая описание структуры базы данных, функционала, а также руководства для пользователей. Это обеспечит удобство в использовании системы и поможет в обучении новых пользователей.

Таким образом, цель работы заключается в создании эффективной базы данных для контроля успеваемости школьников, которая будет способствовать оптимизации процессов управления учебной информацией и повышению качества образования.


#### <a id="tasks">Задачи работы</a>

Для достижения поставленной цели необходимо решить следующие задачи:

1. **Анализировать предметную область контроля успеваемости школьников** Это включает в себя изучение существующих методов учета успеваемости, требований пользователей (учителей, администраторов и родителей) к системе, а также особенностей образовательного процесса. Важно определить, какую информацию необходимо хранить и обрабатывать, а также выявить ключевые проблемы, которые могут быть решены с помощью базы данных.
2. **Проектировать структуру базы данных.** На этом этапе необходимо определить ключевые таблицы, их атрибуты и связи между сущностями. В частности, следует четко определить структуру таблиц. Важно установить правильные типы данных для каждого атрибута и определить, какие ограничения целостности должны быть применены (например, уникальность, проверка значений).
3. **Выбрать и обосновать систему управления базами данных (СУБД)** Необходимо провести анализ различных СУБД (например, MySQL, PostgreSQL, SQLite) с учетом требований проекта, таких как производительность, масштабируемость, простота использования и поддержка необходимых функций. На основании этого анализа следует выбрать наиболее подходящую СУБД и обосновать выбор.
4. **Реализовать структуру базы данных на выбранной СУБД** Это включает в себя написание SQL-запросов для создания таблиц, определения их атрибутов и установления связей между ними. Важно также учесть создание индексов для оптимизации запросов и обеспечения быстрого доступа к данным.
5. **Заполнить базу данных тестовыми данными** Для проверки работоспособности и корректности структуры базы данных необходимо подготовить и вставить тестовые данные в каждую из таблиц. Это позволит убедиться в правильности работы системы и обеспечит возможность тестирования различных функций и запросов.
6. **Разработать и протестировать приложение с использованием Python** для получения необходимых данных. Это включает в себя создание запросов для выборки оценок учеников, получения статистики по успеваемости, а также генерации отчетов для учителей. Важно протестировать эти запросы на корректность и эффективность, убедившись, что они возвращают ожидаемые результаты.
7. **Осуществить тестирование базы данных** На этом этапе необходимо провести комплексное тестирование, чтобы проверить корректность выполнения всех операций, целостность данных и функциональность запросов. Это может включать в себя как ручное тестирование, так и автоматизированные тесты для проверки различных сценариев использования базы данных.
8. **Сформулировать выводы и предложения** по дальнейшему развитию и расширению функционала базы данных. На основе полученных результатов тестирования и анализа работы системы следует сделать выводы о её эффективности, выявить возможные недостатки и предложить пути их устранения. Это может включать в себя рекомендации по улучшению интерфейса, добавлению новых функций или оптимизации структуры базы данных.

Эти задачи направлены на создание эффективного инструмента, который позволит образовательным учреждениям упорядочить данные о успеваемости школьников, автоматизировать ключевые процессы учета и анализа, а также облегчить доступ к информации для всех заинтересованных пользователей.

## <a id="main">Основная часть</a>

#### <a id="analysis">Анализ предметной области. Постановка задачи</a>

1. **Описание предметной области и функции решаемых задач**
    - **Предметная область** данной работы - управление успеваемостью школьников в образовательных учреждениях. Система направлена на автоматизацию процессов учета успеваемости, что позволит учителям эффективно отслеживать достижения учащихся, анализировать их результаты и собственно редактировать значения. Основной целью автоматизации является упрощение работы с данными, надежное хранение данных, повышение прозрачности учебного процесса и улучшение качества образования.
    - **Функции решаемых задач:**
        - **Хранение информации о классах:** Ведение базы данных, содержащей информацию о каждом классе (номер, буква, год начала обучения). Это позволит администраторам легко управлять данными о классах и отслеживать их изменения.
        - **Учет учеников:** Сохранение данных о каждом ученике, включая имя, фамилию, отчество, дату рождения и класс. Это обеспечит возможность быстрого доступа к информации о каждом учащемся и его учебной истории.
        - **Ведение оценок:** Запись оценок учеников по каждому предмету с указанием даты урока, номера урока и учителя. Это позволит формировать полную картину успеваемости каждого ученика и анализировать динамику его успехов.
        - **Обеспечение доступа к информации:** Создание интуитивно понятного интерфейса, который позволит учителям легко находить нужные данные о классах, учениках и их оценках.
        - **Генерация отчетов:** Автоматическое создание отчетов на основе данных, содержащихся в базе, таких как списки учеников с их оценками, статистика успеваемости по классам и предметам, а также информация об учителях их предметах и классах, которые они ведут.
2. **Перечень входных данных.** Для эффективной работы системы необходимы следующие входные данные:
    - **Данные о классах:**
        - Идентификатор класса (ID).
        - Номер класса.
        - Буква класса.
        - Год начала обучения.
    - **Данные о учителях:**
        - Идентификатор учителя (ID).
        - Имя, фамилия и отчество учителя.
        - Предметы, которые ведет учитель.
        - Классы, которым преподает учитель.
        - Логин и пароль, для авторизации.
    - **Данные о учениках:**
        - Идентификатор ученика (ID).
        - Имя, фамилия и отчество ученика.
        - Дата рождения.
        - Класс, к которому принадлежит ученик.
        - Логин и пароль, для авторизации.
        - История, в каких классах ученик учился.
    - **Данные о предметах:**
        - Идентификатор предмета (ID).
        - Название предмета.
    - **Данные о администраторах:**
        - Идентификатор предмета (ID).
        - Логин и пароль, для авторизации.
    - **Данные о оценках:**
        - Идентификатор оценки (ID).
        - Идентификатор ученика.
        - Идентификатор предмета.
        - Идентификатор класса.
        - Идентификатор учителя.
        - Оценка (в диапазоне от 2 до 5).
        - Номер урока.
        - Дата урока.
        - Дата создания оценки.
        - Дата изменения оценки (при необходимости).
 сумма).
3. **Перечень выходных данных.** На основе входных данных система должна предоставить следующие выходные данные:
    - **Отчёт по успеваемости учеников:**
        - Список оценок по предмету у ученика за определенный период.
        - Итоговые оценки за учебные года.
        - Табель оценок по классу.
        - Табель итоговых оценок по классу.
    - **Статистика успеваемости по классам и предметам:**
        - Сравнительный анализ успеваемости класса (изменение оценок за определённый период).
    - **Информация об учителях и их предметах:**
        - Список учителей с указанием предметов и классов которые они ведут.
4. **Ограничения предметной области.** При работе с базой данных могут возникнуть следующие ограничения:
    - **Ограничение по объёму данных:** Увеличение количества учеников, классов и оценок может негативно сказаться на производительности системы. Необходимо учитывать возможность оптимизации базы данных, включая использование индексации и других методов для повышения скорости обработки запросов.
    - **Ограничение по доступу:** Личная информация о учениках и их оценках должна быть защищена от несанкционированного доступа. Это требует реализации надежных механизмов авторизации, чтобы только уполномоченные лица могли получать доступ к конфиденциальной информации.
    - **Ограничение по обновлению данных:** Для предотвращения потери данных необходимо разработать систему резервного копирования. Регулярные бэкапы помогут избежать потерь информации в случае технических сбоев или ошибок пользователей.
5. **Взаимодействие с другими программами.** Система управления успеваемостью может взаимодействовать с различными образовательными и административными системами для расширения функциональности:
    - **Система управления учебным процессом** Интеграция с существующими системами управления учебным процессом позволит автоматизировать обмен данными о расписании уроков, классах и учителях.
    - **Портал для родителей:** Создание веб-портала, где родители смогут отслеживать успеваемость своих детей, получать уведомления о новых оценках и взаимодействовать с учителями.
    - **Система аналитики:** Интеграция с аналитическими платформами (например, Power BI или Google Data Studio) для визуализации данных и создания отчетов, что поможет в анализе успеваемости и выявлении проблемных областей.
    - **Электронный дневник:** Взаимодействие с электронными дневниками, которые позволяют учителям и ученикам отслеживать успеваемость и посещаемость в реальном времени.

#### <a id="infological_model">Инфологическая (концептуальная) модель базы данных</a>

Концептуальная модель базы данных описывает структуру данных, которая будет храниться и обрабатываться в базе, без привязки к конкретной системе управления базами данных (СУБД). В рамках этой модели выделяются ключевые информационные объекты, атрибуты этих объектов, связи между ними, а также мощности отношений, которые определяют тип связей между сущностями.

1. **Выделение информационных объектов.**
    - **Классы** - информация о всех классах за всю историю учебного заведения.
    - **Учителя** - данные о учителях.
    - **Администраторы** - данные об администраторах.
    - **Ученики** - данные о учениках.
    - **Предметы** - информация о том, какие предметы преподаются в учебном заведении.
    - **Оценки** - история всех оценок, за все время.
2. **Определение атрибутов объектов.** Каждая из выделенных сущностей имеют свои уникальные атрибуты, которые описывают их свойства.
    - **Администраторы:**
        - admin_id (Уникальный идентификатор администратора).
        - login.
        - password.
    - **Классы:**
        - class_id (Уникальный идентификатор класса).
        - class_number (Номер класса).
        - class_letter (Буква класса).
        - start_year (Год начала обучения).
    - **Учителя:**
        - teacher_id (Уникальный Идентификатор учителя).
        - first_name (Имя учителя).
	- last_name (Фамилия учителя).
	- second_name (Отчество учителя).
        - Предметы, которые ведет учитель.
        - Классы, которые ведет учитель.
        - login.
        - password.
    - **Ученики:**
        - student_id (Уникальный идентификатор ученика).
        - first_name (Имя ученика).
        - last_name (Фамилия ученика).
	- second_name (Отчество ученика).
        - date_of_birth (Дата рождения).
        - class_id (Класс, к которому принадлежит ученик).
        - history_classes (История классов в которых учился ученик).
        - login.
        - password.
    - **Предметы:**
        - subject_id (Уникальный идентификатор предмета).
        - subject_name (Название предмета).
    - **Оценки:**
        - grade_id (Идентификатор оценки (ID).
        - student_id (Идентификатор ученика).
        - subject_id (Идентификатор предмета).
        - class_id (Идентификатор класса).
        - teacher_id (Идентификатор учителя).
        - grade (Оценка, в диапазоне от 2 до 5).
        - number_lesson (Номер урока).
        - date_lesson (Дата урока).
        - create_date (Дата создания оценки).
        - update_date (Дата изменения оценки).
3. **Определение отношений и мощности отношений между объектами.** В данной базе данных для контроля успеваемости школьников выделены следующие сущности и их взаимосвязи:
- **Класс — Ученик:**
    - **Связь:** один ко многим.
    - **Описание:** Каждый класс может включать множество учеников, однако каждый ученик может быть зачислен только в один конкретный класс. Это позволяет организовать учебный процесс и контролировать успеваемость в рамках определённой группы учащихся.

- **Учитель - Учитель_Предмет:**
    - **Связь:** один ко многим.
    - **Описание:** Один учитель может преподавать несколько предметов, но каждый предмет может быть преподаваться только одним учителем в рамках данного отношения. Это отношение позволяет гибко распределять нагрузки между учителями и эффективно управлять расписанием.

- **Предмет - Учитель_Предмет:**
    - **Связь:** один ко многим.
    - **Описание:** Каждый предмет может быть связан с несколькими учителями, если, например, в разных классах его ведут разные преподаватели. Однако каждый конкретный учитель может преподавать данный предмет только в рамках своей учебной нагрузки.

- **Ученик - Оценка:**
    - **Связь:** один ко многим.
    - **Описание:** Один ученик может получать множество оценок по различным предметам на протяжении учебного года. Каждая оценка, в свою очередь, относится только к одному ученику, что позволяет отслеживать его успеваемость и динамику обучения.

- **Предмет - Оценка:**
    - **Связь:** один ко многим.
    - **Описание:** Каждый предмет может иметь множество оценок, выставленных ученикам. Каждая оценка привязана к конкретному предмету, что позволяет анализировать успеваемость по каждому предмету в отдельности.

- **Учитель - Оценка:**
    - **Связь:** один ко многим.
    - **Описание:** Один учитель может выставлять множество оценок своим ученикам, но каждая оценка выставляется только одним учителем. Это отношение обеспечивает прозрачность и ответственность в процессе оценки успеваемости.

- **Класс - Оценка:**
    - **Связь:** один ко многим.
    - **Описание:** Каждый класс может иметь множество оценок, выставленных его ученикам. Каждая оценка относится к конкретному классу, что позволяет анализировать успеваемость всего класса в целом.

- **Оценка - Урок:**
    - **Связь:** один ко многим.
    - **Описание:** Каждая оценка относится к конкретному уроку, но один урок может иметь множество оценок, выставленных различным ученикам. Это позволяет детально отслеживать успеваемость на уровне отдельных занятий.

Каждое из этих отношений помогает структурировать данные в базе и обеспечивает возможность глубокого анализа успеваемости школьников, а также управления учебным процессом.

4. **Построение концептуальной модели.** На основе выделенных сущностей, их атрибутов и связей между ними можно построить концептуальную ER-диаграмму для базы данных, предназначенной для контроля успеваемости школьников.

![Screenshot_7](https://github.com/user-attachments/assets/f81b4a28-c905-4ced-b28b-c26572c3caa7)

Эта концептуальная модель позволяет наглядно представить структуру базы данных, а также связи между различными сущностями, что упрощает дальнейшее проектирование и реализацию системы контроля успеваемости школьников.

#### <a id="logical_structure">Логическая структура базы данных</a>

Логическая структура базы данных представляет собой детализированное описание таблиц, их атрибутов, типов данных, а также ключевых ограничений и правил целостности. На основе концептуальной модели можно построить логическую структуру, которая будет готова для реализации в системе управления базами данных (СУБД).

В данной структуре будут определены следующие таблицы: **Администраторы**, **Классы**, **Учителя**, **Ученики**, **Предметы**, **Учитель_Предмет**, **Учитель_Класс**, **Оценки**, а также связи между ними.

#### Определение таблиц и их атрибутов

1. **Таблица "Администраторы"**
    - **admin_id** (Primary Key) - уникальный идентификатор администратора (целое число).
    - **login** - логин администратора (строка).
    - **password** - пароль администратора (строка).

    **Типы данных:**
    - admin_id - SERIAL.
    - login - VARCHAR(50).
    - password - VARCHAR(50).

    **Ограничения:**
    - admin_id является уникальным и не может быть NULL.
    - login является уникальным и не может быть NULL.
    - password не может быть NULL.

2. **Таблица "Классы"**
    - **class_id** (Primary Key) - уникальный идентификатор класса (целое число).
    - **class_number** - номер класса (целое число).
    - **class_letter** - буква класса (строка).
    - **start_year** - год начала обучения (дата).

    **Типы данных:**
    - class_id - SERIAL.
    - class_number - INT.
    - class_letter - VARCHAR(5).
    - start_year - DATE.

    **Ограничения:**
    - class_id является уникальным и не может быть NULL.
    - class_number не может быть NULL.
    - class_letter не может быть NULL.
    - start_year не может быть NULL.

3. **Таблица "Учителя"**
    - **teacher_id** (Primary Key) - уникальный идентификатор учителя (целое число).
    - **first_name** - имя учителя (строка).
    - **last_name** - фамилия учителя (строка).
    - **second_name** - отчество учителя (строка).
    - **login** - логин учителя (строка).
    - **password** - пароль учителя (строка).
    - **deleted** - статус удаления (логическое значение).

    **Типы данных:**
    - teacher_id - SERIAL.
    - first_name - VARCHAR(50).
    - last_name - VARCHAR(50).
    - second_name - VARCHAR(50).
    - login - VARCHAR(50).
    - password - VARCHAR(50).
    - deleted - BOOLEAN.

    **Ограничения:**
    - teacher_id является уникальным и не может быть NULL.
    - login является уникальным и не может быть NULL.
    - password не может быть NULL.

4. **Таблица "Ученики"**
    - **student_id** (Primary Key) - уникальный идентификатор ученика (целое число).
    - **first_name** - имя ученика (строка).
    - **last_name** - фамилия ученика (строка).
    - **second_name** - отчество ученика (строка).
    - **date_of_birth** - дата рождения ученика (дата).
    - **class_id** (Foreign Key) - ссылка на таблицу **Классы** (целое число).
    - **history_classes** - история классов (строка).
    - **login** - логин ученика (строка).
    - **password** - пароль ученика (строка).

    **Типы данных:**
    - student_id - SERIAL.
    - first_name - VARCHAR(50).
    - last_name - VARCHAR(50).
    - second_name - VARCHAR(50).
    - date_of_birth - DATE.
    - class_id - INT.
    - history_classes - VARCHAR(8000).
    - login - VARCHAR(50).
    - password - VARCHAR(50).

    **Ограничения:**
    - student_id является уникальным и не может быть NULL.
    - class_id является внешним ключом, который ссылается на таблицу **Классы**.
    - date_of_birth должна быть меньше текущей даты.

5. **Таблица "Предметы"**
    - **subject_id** (Primary Key) - уникальный идентификатор предмета (целое число).
    - **subject_name** - название предмета (строка).

    **Типы данных:**
    - subject_id - SERIAL.
    - subject_name - VARCHAR(50).

    **Ограничения:**
    - subject_id является уникальным и не может быть NULL.
    - subject_name не может быть NULL.

6. **Таблица "Учитель_Предмет"**
    - **teacher_id** (Foreign Key) - ссылка на таблицу **Учителя** (целое число).
    - **subject_id** (Foreign Key) - ссылка на таблицу **Предметы** (целое число).

    **Типы данных:**
    - teacher_id - INT.
    - subject_id - INT.

    **Ограничения:**
    - teacher_id и subject_id вместе образуют составной первичный ключ и не могут быть NULL.

7. **Таблица "Учитель_Класс"**
    - **teacher_id** (Foreign Key) - ссылка на таблицу **Учителя** (целое число).
    - **class_id** (Foreign Key) - ссылка на таблицу **Классы** (целое число).

    **Типы данных:**
    - teacher_id - INT.
    - class_id - INT.

    **Ограничения:**
    - teacher_id и class_id вместе образуют составной первичный ключ и не могут быть NULL.

8. **Таблица "Оценки"**
    - **grade_id** (Primary Key) - уникальный идентификатор оценки (целое число).
    - **student_id** (Foreign Key) - ссылка на таблицу **Ученики** (целое число).
    - **class_id** (Foreign Key) - ссылка на таблицу **Классы** (целое число).
    - **subject_id** (Foreign Key) - ссылка на таблицу **Предметы** (целое число).
    - **teacher_id** (Foreign Key) - ссылка на таблицу **Учителя** (целое число).
    - **grade** - оценка (целое число, допустимые значения: 2, 3, 4, 5).
    - **number_lesson** - номер урока (целое число).
    - **date_lesson** - дата урока (дата).
    - **create_date** - дата создания записи (дата).
    - **update_date** - дата обновления записи (дата).

    **Типы данных:**
    - grade_id - SERIAL.
    - student_id - INT.
    - class_id - INT.
    - subject_id - INT.
    - teacher_id - INT.
    - grade - INT.
    - number_lesson - INT.
    - date_lesson - DATE.
    - create_date - DATE.
    - update_date - DATE.

    **Ограничения:**
    - grade_id является уникальным и не может быть NULL.
    - student_id, class_id, subject_id и teacher_id являются внешними ключами, которые ссылаются на соответствующие таблицы.
    - grade должен быть в диапазоне от 2 до 5.


**Нормализация базы данных**

На данном этапе структура базы данных приведена к третьей нормальной форме (3NF), что позволяет:

- Устранить избыточность данных.
- Избежать аномалий при добавлении, изменении и удалении данных.
- Обеспечить более эффективное использование памяти и более быструю обработку запросов.


## <a id="physical_structure">Физическая структура базы данных</a>

Физическая структура базы данных отвечает за реальное хранение данных на физическом уровне, определяет способы хранения и работы с данными, обеспечивая при этом их целостность, доступность и производительность системы. На этом этапе важно учитывать оптимизацию производительности запросов, объёмы данных и ограничения, связанные с физическим хранением данных в выбранной СУБД. В данной курсовой работе предполагается использование реляционной СУБД (PostgreSQL), так как она предоставляет оптимальные средства для управления табличными данными и поддерживает сложные связи между данными, что необходимо для образовательной организации.

Физическая структура проектируется таким образом, чтобы система максимально эффективно обрабатывала данные, предоставляя пользователю доступ к нужной информации с минимальной задержкой. Это достигается с помощью выбора правильных типов данных, индексов, механизмов хранения и настройки параметров, обеспечивающих производительность и надежность.

1. **Выбор типов данных**

Правильный выбор типов данных для полей таблиц — один из ключевых аспектов проектирования физической структуры базы данных, так как это позволяет экономить ресурсы и повышать производительность.

**Рассмотрим выбор типов данных для каждой таблицы:**

- **SERIAL** — используется для автоинкрементных значений, таких как идентификаторы записей. Это подходит для полей, которые используются как ключи и часто участвуют в соединениях и фильтрации данных.
- **INT** — используется для целочисленных значений, занимает фиксированный объем памяти и обеспечивает эффективное индексирование, что важно для первичных и внешних ключей. Это подходит для полей, которые используются как ключи и часто участвуют в соединениях и фильтрации данных.
- **VARCHAR(n)** — применяется для хранения текстовых данных переменной длины, таких как имена, названия и описания. Этот тип позволяет оптимально расходовать память, так как фактически занимает объем, соответствующий реальной длине строки.
- **DATE** — этот тип данных используется для хранения дат. Он позволяет хранить значения в формате даты (год, месяц, день) и обеспечивает удобные функции для работы с датами, такие как сравнение и вычисление разницы между датами.
- **BOOLEAN** — используется для хранения логических значений, которые могут принимать два состояния: TRUE (истина) или FALSE (ложь). Он часто используется для представления бинарных состояний, таких как наличие или отсутствие, активный или неактивный статус. Например, поле deleted в таблице Teachers указывает, был ли учитель удален.

Тип данных влияет на объем занимаемой памяти и производительность базы данных, так как данные записываются и извлекаются в зависимости от того, какой тип используется.

**Пример SQL-кода с применением типов данных для таблицы "Оценки":**

```
CREATE TABLE Grades (
    grade_id SERIAL PRIMARY KEY,
    student_id INT,
    class_id INT,
    subject_id INT,
    teacher_id INT,
    grade INT CHECK (grade IN (2, 3, 4, 5)),
    number_lesson INT NOT NULL,
    date_lesson DATE NOT NULL,
    create_date DATE NOT NULL,
    update_date DATE default null,
    FOREIGN KEY (student_id) REFERENCES Students(student_id),
    FOREIGN KEY (subject_id) REFERENCES Subjects(subject_id),
    FOREIGN KEY (teacher_id) REFERENCES Teachers(teacher_id),
    FOREIGN KEY (class_id) REFERENCES Classes(class_id)
);
```

2. **Оптимизация индексов**

Индексы являются ключевым элементом в оптимизации базы данных, так как они позволяют ускорить доступ к данным и облегчают выполнение запросов, таких как поиск, фильтрация и сортировка. Индексы создаются для полей, которые часто участвуют в поисковых запросах и соединениях таблиц.

- **Первичные ключи** автоматически индексируются, так как они служат для уникальной идентификации каждой записи. Это гарантирует быстрое выполнение операций поиска и обновления записей.
- **Внешние ключи** (например, student_id, class_id, subject_id, teacher_id) также индексируются, чтобы ускорить выполнение соединений между таблицами. Внешние ключи позволяют поддерживать целостность данных, предотвращая создание записей, не соответствующих связанным данным.
- **Дополнительные индексы** — могут быть добавлены для часто запрашиваемых полей, например, для поля lesson_date в таблице Оценки, если предполагается, что пользователи часто будут искать оценки по дате.

**Создание индексов, используемых в условиях WHERE:**

```
CREATE INDEX idx_students_login ON Students (login);
CREATE INDEX idx_teachers_login ON Teachers (login);
CREATE INDEX idx_classes_class_number_letter ON Classes (class_number, class_letter);
CREATE INDEX idx_grades_student_id ON Grades (student_id);
CREATE INDEX idx_grades_class_id ON Grades (class_id);
CREATE INDEX idx_grades_subject_id ON Grades (subject_id);
CREATE INDEX idx_grades_teacher_id ON Grades (teacher_id);
```

**Создание индексов, используемых в условиях JOIN:**

```
CREATE INDEX idx_teacher_classes_teacher_id ON Teacher_Classes (teacher_id);
CREATE INDEX idx_teacher_subject_teacher_id ON Teacher_Subject (teacher_id);
```

**Создание индексов, используемых в условиях ORDER BY и GROUP BY:**

```
CREATE INDEX idx_grades_date_lesson ON Grades (date_lesson);
CREATE INDEX idx_grades_student_class_subject ON Grades (student_id, class_id, subject_id);
```

**Преимущества индексов:**

- Ускоряют поиск и сортировку.
- Повышают производительность запросов с условиями фильтрации.
- Уменьшают время выполнения операций соединения.

**Недостаток индексов:**
- Индексы занимают место и могут замедлить операции вставки, обновления и удаления, так как индексы также нужно обновлять.

3. **Таблицы и кластеризация данных**

Кластеризация позволяет физически упорядочивать записи на диске по значению индекса, что может существенно ускорить выполнение запросов, в которых данные фильтруются и сортируются по определенному столбцу. Например, таблицу Оценки можно упорядочить по lesson_date, чтобы данные о занятиях находились физически рядом. Это улучшает производительность запросов, касающихся конкретных уроков, так как чтение данных с диска выполняется быстрее.

4. **Механизм хранения и параметры оптимизации**

PostgreSQL использует механизм хранения данных, поддерживающий многоверсионность (MVCC, Multiversion Concurrency Control), что позволяет эффективно управлять транзакциями и конкурентным доступом к данным. В отличие от MySQL, PostgreSQL не требует явного указания механизма хранения при создании таблиц, так как все таблицы автоматически используют встроенный механизм. Этот механизм обеспечивает высокий уровень надежности, особенно для данных, подверженных частым изменениям, и поддерживает управление транзакциями, что критично для точности и согласованности данных.

**Преимущества MVCC в PostgreSQL для базы данных**

- **Поддержка транзакций** — гарантирует согласованность данных. Каждая транзакция выполняется как отдельная операция, и в случае неудачи все изменения отменяются.
- **Конкурентный доступ** — PostgreSQL позволяет нескольким пользователям одновременно работать с данными, обеспечивая при этом изоляцию транзакций, что делает его особенно подходящим для высоконагруженных приложений, где требуется частое обновление данных.
- **Гибкое управление блокировками** — позволяет предотвращать конфликты между транзакциями и поддерживает высокую производительность.

**Особенности PostgreSQL при создании таблиц:**

- **Тип SERIAL** — используется для создания автоинкрементных первичных ключей. В PostgreSQL SERIAL автоматически создает последовательность и обеспечивает уникальные значения для каждого нового элемента, что упрощает настройку первичных ключей.
- **CHECK-ограничения** — PostgreSQL поддерживает гибкие ограничения, которые помогают контролировать значения в полях. Например, ограничения на поле **Оценка** гарантирует, что значения будут только 2, 3, 4 или 5.

5. **Политики управления целостностью данных**

PostgreSQL предоставляет богатый функционал для поддержания целостности данных с использованием различных ограничений и ключей. Эти механизмы помогают гарантировать, что база данных всегда находится в согласованном состоянии.

**Основные элементы для управления целостностью:**

- **Первичные ключи (PRIMARY KEY)** — используются для уникальной идентификации записей в таблицах. В PostgreSQL первичные ключи создаются с использованием уникального индекса и автоматически проверяют уникальность значения.
- **Внешние ключи (FOREIGN KEY)** — обеспечивают целостность ссылочной структуры между таблицами. Внешние ключи используются, чтобы установить зависимость между записями. Например, в таблице Оценки внешний ключ student_id гарантирует, что ученик будет существовать в таблице Ученики.
- **Ограничения NOT NULL** — применяются к полям, значения в которых обязательно должны быть указаны. Поля, такие как grade и lesson_date, не могут быть пустыми, так как эти данные являются обязательными для бизнес-процессов.
- **CHECK-ограничения** — применяются для контроля значений полей в соответствии с установленными правилами. Например, в поле grade вводятся только значения 2, 3, 4 или 5, что соответствует оценочной системе.

```
CREATE TABLE Students (
    student_id SERIAL PRIMARY KEY,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    date_of_birth DATE NOT NULL,
    class_id INT NOT NULL,
    CHECK (date_of_birth < CURRENT_DATE),
    FOREIGN KEY (class_id) REFERENCES Классы(class_id)
);
```

В этом примере используется регулярное выражение для проверки, что дата рождения должна быть раньше нынешней даты.

**Другие механизмы управления целостностью:**

- **Триггеры** — PostgreSQL поддерживает триггеры, которые позволяют выполнять дополнительные проверки и операции при добавлении, обновлении или удалении записей. Триггеры могут использоваться для автоматической записи истории изменений или для сложных проверок целостности, когда стандартных ограничений недостаточно.
- **Индексы** — PostgreSQL автоматически создает индексы для полей, которые заданы как первичные ключи или уникальные. Это улучшает производительность запросов, так как индекс ускоряет поиск и доступ к данным.
- **Управление транзакциями** — PostgreSQL поддерживает уровни изоляции транзакций, которые позволяют определять правила работы с параллельными запросами.

Таким образом, механизмы управления целостностью в PostgreSQL обеспечивают надежную работу базы данных, поддерживая высокую степень согласованности и производительности.

6. **Параметры хранения и резервное копирование**

Для обеспечения надежности базы данных образовательной организации и защиты от потерь данных, в PostgreSQL необходимо организовать систему резервного копирования и продумать параметры хранения. PostgreSQL предлагает несколько методов резервного копирования и восстановления данных, а также настройки, которые влияют на производительность и безопасность системы.

**Резервное копирование**

PostgreSQL поддерживает два основных типа резервного копирования:

- **Логическое резервное копирование** — выполняется с помощью утилиты pg_dump. Этот метод позволяет копировать структуру и данные одной или нескольких баз данных. Логическое копирование используется в ситуациях, когда требуется гибкость, например, для восстановления на другой версии PostgreSQL или для миграции данных.

Пример использования pg_dump для создания резервной копии:

```
pg_dump -U username -F c -b -v -f "backup_filename.backup" database_name
```

Этот скрипт сохраняет базу данных в формате архивного файла, который затем можно будет использовать для восстановления.

- **Физическое резервное копирование** — выполняется путем копирования файлов данных на уровне файловой системы. PostgreSQL предоставляет инструмент pg_basebackup, который выполняет копирование всех файлов базы данных и создаёт полную копию в заданном каталоге.

Пример использования pg_basebackup:

```
pg_basebackup -U postgres -D /path/to/backup -Ft -z -P
```

Физическое резервное копирование особенно полезно для больших баз данных и высоконагруженных систем, так как оно позволяет быстрее восстанавливать данные и поддерживать согласованность на уровне файлов.

7. **SQL-код создания таблиц с физической структурой для PostgreSQL**

В этом разделе приводится полный пример SQL-кода для создания таблиц, описанных в предыдущих разделах. Каждая таблица строится с учетом требований физической структуры базы данных и с использованием всех механизмов PostgreSQL для оптимизации, поддержки целостности и обеспечения надежности данных.

```
-- Создание таблицы Администраторы
CREATE TABLE Admins (
    admin_id SERIAL PRIMARY KEY,
    login VARCHAR(50) UNIQUE NOT NULL,
    password VARCHAR(50) NOT NULL
);


-- Создание таблицы Классы
CREATE TABLE Classes (
    class_id SERIAL PRIMARY KEY,
    class_number INT NOT NULL,
    class_letter VARCHAR(5) NOT null,
    start_year DATE NOT NULL
);

-- Создание таблицы Учителя
CREATE TABLE Teachers (
    teacher_id SERIAL PRIMARY KEY,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    second_name VARCHAR(50) NOT null,
    login VARCHAR(50) UNIQUE NOT NULL,
  password VARCHAR(50) NOT NULL,
  deleted BOOLEAN NOT NULL DEFAULT FALSE
);

-- Создание таблицы Ученики
CREATE TABLE Students (
    student_id SERIAL PRIMARY KEY,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    second_name VARCHAR(50) NOT NULL,
    date_of_birth DATE NOT NULL,
    class_id INT,
    history_classes VARCHAR(8000) DEFAULT NULL,
    login VARCHAR(50) UNIQUE NOT NULL,
  password VARCHAR(50) NOT NULL,
    CHECK (date_of_birth < CURRENT_DATE),
    FOREIGN KEY (class_id) REFERENCES Classes(class_id)
);

-- Создание таблицы Предметы
CREATE TABLE Subjects (
    subject_id SERIAL PRIMARY KEY,
    subject_name VARCHAR(50) NOT NULL
);

-- Создание таблицы Учитель_Предмет
CREATE TABLE Teacher_Subject (
    teacher_id INT,
    subject_id INT,
    PRIMARY KEY (teacher_id, subject_id),
    FOREIGN KEY (teacher_id) REFERENCES Teachers(teacher_id),
    FOREIGN KEY (subject_id) REFERENCES Subjects(subject_id)
);

-- Создание таблицы Учитель_Класс
CREATE TABLE Teacher_Classes (
    teacher_id INT,
    class_id INT,
    PRIMARY KEY (teacher_id, class_id),
    FOREIGN KEY (teacher_id) REFERENCES Teachers(teacher_id),
    FOREIGN KEY (class_id) REFERENCES Classes(class_id)
);


-- Создание таблицы Оценки
CREATE TABLE Grades (
    grade_id SERIAL PRIMARY KEY,
    student_id INT,
    class_id INT,
    subject_id INT,
    teacher_id INT,
    grade INT CHECK (grade IN (2, 3, 4, 5)),
    number_lesson INT NOT NULL,
    date_lesson DATE NOT NULL,
    create_date DATE NOT NULL,
    update_date DATE default null,
    FOREIGN KEY (student_id) REFERENCES Students(student_id),
    FOREIGN KEY (subject_id) REFERENCES Subjects(subject_id),
    FOREIGN KEY (teacher_id) REFERENCES Teachers(teacher_id),
    FOREIGN KEY (class_id) REFERENCES Classes(class_id)
);


-- Индексы для оптимизации запросов
CREATE INDEX idx_students_login ON Students (login);
CREATE INDEX idx_teachers_login ON Teachers (login);
CREATE INDEX idx_classes_class_number_letter ON Classes (class_number, class_letter);
CREATE INDEX idx_grades_student_id ON Grades (student_id);
CREATE INDEX idx_grades_class_id ON Grades (class_id);
CREATE INDEX idx_grades_subject_id ON Grades (subject_id);
CREATE INDEX idx_grades_teacher_id ON Grades (teacher_id);
CREATE INDEX idx_teacher_classes_teacher_id ON Teacher_Classes (teacher_id);
CREATE INDEX idx_teacher_subject_teacher_id ON Teacher_Subject (teacher_id);
CREATE INDEX idx_grades_date_lesson ON Grades (date_lesson);
CREATE INDEX idx_grades_student_class_subject ON Grades (student_id, class_id, subject_id);
```

**Описание и обоснование SQL-кода**

- **Создание таблиц:** Каждая таблица создается с использованием типа SERIAL для первичного ключа, который обеспечивает автоинкремент и уникальность записи. Поля, содержащие важные текстовые данные, используются с типом VARCHAR, а для целочисленных значений и дат применяется тип INT и DATE соответственно.
- **Ограничения целостности:** В таблицах установлены внешние ключи для обеспечения ссылочной целостности. Например, class_id в таблице Students ссылается на таблицу Classes, что гарантирует, что каждый ученик будет принадлежать к существующему классу.
- **Индексы:** Добавлены индексы для полей, которые часто участвуют в запросах.
- **CHECK-ограничения:** Дополнительные ограничения установлены на такие поля, как grade, чтобы защитить базу данных от некорректных значений и обеспечить соответствие данных бизнес-логике.

Этот SQL-код и структура таблиц обеспечивают надежную физическую реализацию базы данных в PostgreSQL для образовательной организации, удовлетворяя всем требованиям по целостности, производительности и масштабируемости.

#### <a id="project_realization">Реализация проекта в среде конкретной СУБД</a>

Этот раздел курсовой работы описывает практическую реализацию базы данных в PostgreSQL. Рассматриваются основные этапы — от создания таблиц и запросов до разработки интерфейса, индексов и резервного копирования.

1. **Создание таблиц и индексов**


```
SQL-код публиковался выше
```

2. **Создание представлений и функций**

- **Для удобства работы, реализовано представления для оценок и для классов, которые ведет учитель:**
- 
```
CREATE OR REPLACE VIEW student_grades AS
SELECT
    g.grade_id,
    s.student_id,
    s.first_name AS student_first_name,
    s.last_name AS student_last_name,
    sub.subject_name,
    g.grade,
    g.create_date,
    c.class_number,
    c.class_letter,
    g.class_id,
    g.subject_id,
    g.date_lesson
FROM
    Grades g
JOIN
    Students s ON g.student_id = s.student_id
JOIN
    Subjects sub ON g.subject_id = sub.subject_id
JOIN
    Classes c ON g.class_id = c.class_id;
```

```
CREATE OR REPLACE VIEW Teacher_Classes_View AS
SELECT 
    tc.teacher_id,
    c.class_id,
    c.class_number,
    c.class_letter
FROM 
    Teacher_Classes tc
JOIN 
    Classes c ON tc.class_id = c.class_id;

```


- **Функция для добавление оценки:**

```
CREATE OR REPLACE FUNCTION add_grade(
    p_student_id INT,
    p_class_id INT,
    p_subject_id INT,
    p_teacher_id INT,
    p_grade INT,
    p_number_lesson INT,
    p_date_lesson DATE,
    p_create_date DATE
) RETURNS VOID AS $$
BEGIN
    INSERT INTO Grades (student_id, class_id, subject_id, teacher_id, grade, number_lesson, date_lesson, create_date)
    VALUES (p_student_id, p_class_id, p_subject_id, p_teacher_id, p_grade, p_number_lesson, p_date_lesson, p_create_date);
END;
$$ LANGUAGE plpgsql;
```

- **Функция для изменения оценки:**

```
CREATE OR REPLACE FUNCTION update_grade(
    p_grade_id INT,
    p_new_grade INT
) RETURNS VOID AS $$
BEGIN
    UPDATE Grades
    SET grade = p_new_grade, update_date = CURRENT_DATE
    WHERE grade_id = p_grade_id;
END;
$$ LANGUAGE plpgsql;

```

3. **Разработка интерфейса**

Интерфейс для взаимодействия с базой данных будем создавать с помощью инструментов построения интерфейсов в Python, таких как tkinter. **Основные функции интерфейса должны включать:**

- **Авторизацию** — авторизация под учеником, учителем или администратором.
- **Отображение существующих оценок** — табели оценок, оценки конкретного ученика.
- **Добавление и обновление данных** — формы для изменения оценок у учеников.
- **Анализ данных** — сравнительный анализ успеваемости учащихся.

На языке Python и tkinter можно создать простое приложение, выполняющее данные функции.

4. **Назначение прав доступа**

В целях безопасности база данных может иметь следующие роли:

- **Администратор** — имеет возможность добавлять удалять учителей, редактировать зоны отвественности учителей.
- **Учитель** — может обновлять и контроллировать успеваемость прикрепленных к нему классов, только по тем предметам которые ведет данный учитель.
- **Ученик** — может только просматривать информацию о своих оценках.


5. **Разработка стратегии резервного копирования базы данных**

Для защиты данных от сбоев и потерь необходимо разработать стратегию регулярного резервного копирования. Для PostgreSQL основными методами являются:

- **Ежедневное логическое резервное копирование с помощью pg_dump** — позволяет создавать бэкап базы данных в формате SQL. Эти резервные копии можно хранить на удаленном сервере или в облаке.

Пример ежедневного резервного копирования:

```
pg_dump -U postgres -F c -b -v -f "/backups/backup_$(date +\%Y\%m\%d).backup" postgres
```

- **Полное физическое резервное копирование раз в неделю с использованием pg_basebackup** — особенно полезно для больших объемов данных, так как обеспечивает быстрое восстановление базы данных.

Пример команды:

```
pg_basebackup -U postgres -D /path/to/backup -Ft -z -P
```

- **Проверка и тестирование восстановлений** — резервное копирование должно регулярно тестироваться на восстановление, чтобы убедиться в работоспособности резервных копий. Это критически важно для обеспечения постоянной доступности и надежности данных.

Стратегия резервного копирования должна включать хранение нескольких копий данных на случай различных инцидентов, таких как сбой оборудования или ошибка администратора.

### <a id="conclusion">Заключение</a>

В результате выполнения курсовой работы была разработана база данных для контроля успеваемости школьников, которая отвечает современным требованиям образовательного процесса. Основные достижения и выводы работы:

- **Анализ предметной области**: Проведен детальный анализ существующих методов учета успеваемости, что позволило выявить ключевые проблемы и требования пользователей к системе.

- **Проектирование структуры базы данных**: Создана логическая и физическая структура базы данных, включающая таблицы для администраторов, классов, учителей, учеников, предметов и оценок. Все таблицы нормализованы до третьей нормальной формы, что обеспечивает целостность и согласованность данных.

- **Реализация функционала**: Разработаны функции для ввода и обновления данных, а также представления для анализа успеваемости. Это позволяет пользователям легко управлять информацией и получать необходимые отчеты.

- **Обеспечение безопасности**: Внедрена система прав доступа, что гарантирует защиту конфиденциальной информации о школьниках и их успеваемости.

- **Тестирование и документация**: Проведено тестирование базы данных на корректность выполнения операций и целостность данных. Подготовлена техническая документация, что обеспечит удобство в использовании системы и поможет в обучении новых пользователей.

Таким образом, разработанная база данных является эффективным инструментом для управления успеваемостью школьников, что способствует оптимизации учебного процесса и повышению качества образования.

## <a id="literature">Список использованных информационных источников</a>

1. **Онлайн-ресурсы:**
   - PostgreSQL. (n.d.). *PostgreSQL Documentation*. Retrieved from [https://www.postgresql.org/docs/](https://www.postgresql.org/docs/)
   - PGdocs. (n.d.). *Введние в представления*. Retrieved from [https://pgdocs.ru/gruber/ch20.html](https://pgdocs.ru/gruber/ch20.html)
   - Хабр. (n.d.). *Индексы в PostgreSQL*. Retrieved from [https://habr.com/ru/companies/postgrespro/articles/326096/](https://habr.com/ru/companies/postgrespro/articles/326096/)
   - SQL-Ex blog. (n.d.). *Функции PostgreSQL: сила функций пользователя*. Retrieved from [https://sql-ex.com/blogs/?/Funkcii_PostgreSQL_sila_funkcij_polzovatelJa.html](https://sql-ex.com/blogs/?/Funkcii_PostgreSQL_sila_funkcij_polzovatelJa.html)

2. **Справочные системы:**
   - DBeaver. (n.d.). *DBeaver Documentation*. Retrieved from [https://dbeaver.com/docs/dbeaver/](https://dbeaver.com/docs/dbeaver/)
   - docs.python.org. (n.d.). *tkinter Documentation*. Retrieved from [https://docs.python.org/3/library/tkinter.html](https://docs.python.org/3/library/tkinter.html)
   - Psycopg. (n.d.). *Psycopg – PostgreSQL database adapter for Python*. Retrieved from [https://www.psycopg.org/docs/](https://www.psycopg.org/docs/)

## <a id="applications">Приложения</a>

В данном разделе представлены приложения, использованные в курсовой работе.

#### Приложение 1: Код приложения на Python

В этом приложении представлен код, написанный на tkinter и psycopg2, Python для взаимодействия с базой данных.

[Код приложения на Python](/visual.py)

#### Приложение 2: Презентация

Презентация, подготовленная для защиты курсовой работы, содержит основные моменты и выводы.

[Презентация](/presentation.pptx)

#### Приложение 3: Текстовая речь

Текстовая версия речи, произнесенной во время защиты курсовой работы, доступна в формате .txt

[Текст речи](/text.txt)

#### Приложение 4: SQL-запросы на заполнение таблиц

В этом приложении представлены SQL-запросы для импорта данных в таблицы, использованные в процессе разработки базы данных.

[SQL-запросы](/sql.sql)

[Вернуться к содержанию](#content)
