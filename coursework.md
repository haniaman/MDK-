# МИНИСТЕРСТВО ОБРАЗОВАНИЯ, НАУКИ И МОЛОДЁЖНОЙ ПОЛИТИКИ РЕСПУБЛИКИ КОМИ

Государственное профессиональное образовательное учреждение
"Сыктывкарский политехнический техникум"

## Задание на курсовую работу по МДК 11.01 "Технология разработки и защиты баз данных"

Тема: База данных для контроля успеваемости школьников

**Профессия / специальность**

09.02.07 "Информационные системы и программирование"

**Выполнил**

Попов Владислав Александрович

Дневная, 4 курс, 414гр.

**Руководитель**

Пунгин И.В.

Срок представления работы к защите: Апрель 2025 года.

### Содержание

1. [Введение](#introduction)
    - [Цель работы](#target)
    - [Задачи работы](#tasks)
2. [Основная часть](#main)
    - [Анализ предметной области. Постановка задачи](#analysis)
    - [Инфологическая (концептуальная) модель базы данных](#infological_model)
    - [Логическая структура БД](#logical_structure)
    - [Физическая структура базы данных](#physical_structure)
    - [Реализация проекта в среде конкретной СУБД](#project_realization)
3. [Заключение](#Conclusion)

### <a id="introduction">Введение</a>

В современном образовательном процессе важным аспектом является контроль успеваемости школьников. Успехи учащихся в учебе напрямую влияют на их дальнейшую судьбу, определяя как их академическую, так и профессиональную траекторию. В условиях быстро меняющегося мира, где информация становится основным ресурсом, эффективное управление данными о успеваемости учащихся становится необходимостью. Это обуславливает актуальность разработки базы данных (БД) для контроля успеваемости школьников, которая позволит не только хранить информацию, но и анализировать её, что в свою очередь способствует повышению качества образования.
Система контроля успеваемости должна обеспечивать удобный доступ к информации для учителей, администраторов и самих учеников. Она должна включать в себя данные о классах, учениках, предметах, оценках и учителях. Важно, чтобы такая система была гибкой и масштабируемой, чтобы её можно было адаптировать под различные образовательные учреждения с учетом их специфики и потребностей. Внедрение базы данных позволит автоматизировать процессы, связанные с ведением учета успеваемости, что существенно сократит время на выполнение рутинных задач и снизит вероятность ошибок, связанных с ручным вводом данных.
Ключевой задачей, стоящей перед разработкой БД, является создание интуитивно понятного интерфейса, который позволит пользователям легко ориентироваться в системе и быстро получать необходимую информацию. Это включает в себя возможность ввода новых данных, редактирования существующих записей, а также генерации отчетов по успеваемости учащихся. Система должна быть способна обрабатывать запросы различной сложности, от простых выборок оценок до сложных аналитических отчетов, которые могут помочь в принятии решений по улучшению учебного процесса.
Кроме того, важным аспектом является обеспечение безопасности данных. В условиях, когда информация о школьниках и их успеваемости является конфиденциальной, необходимо предусмотреть механизмы защиты данных от несанкционированного доступа. Это может включать в себя систему прав доступа, которая будет ограничивать возможности пользователей в зависимости от их роли в системе (учитель, администратор, ученик).
В результате реализации данного проекта будет создана эффективная система, способная не только хранить данные, но и анализировать их, предоставляя пользователям мощные инструменты для работы с информацией. Это, в свою очередь, позволит образовательным учреждениям улучшить качество обучения и повысить уровень успеваемости учащихся. Таким образом, курсовая работа направлена на разработку базы данных для контроля успеваемости школьников, которая будет отвечать современным требованиям и способствовать оптимизации учебного процесса.


#### <a id="target">Цель работы</a>

Целью данной курсовой работы является разработка базы данных для контроля успеваемости школьников, которая позволит эффективно управлять информацией о студентах и их оценках, а также обеспечить доступ к этой информации для различных пользователей. В рамках работы предполагается:
    1. Создание структуры базы данных: На основе уже разработанной схемы базы данных, включающей таблицы "Администраторы", "Классы", "Учителя", "Ученики", "Предметы", "Учитель_Предмет", "Учитель_Класс" и "Оценки", будет проведен анализ и уточнение структуры, чтобы обеспечить целостность и согласованность данных. Важно, чтобы каждая таблица адекватно отражала сущности предметной области и их взаимосвязи.
    2. Реализация функционала для ввода и обновления данных: Разработка функций для добавления и изменения оценок, а также для управления данными о студентах, учителях и предметах. Это позволит пользователям (учителям и администраторам) легко вводить новые данные, обновлять существующие записи и поддерживать актуальность информации.
    3. Создание представлений и запросов для анализа успеваемости: Реализация представлений, которые будут агрегировать данные о успеваемости учеников по предметам и классам. Это позволит учителям и администраторам быстро получать информацию о текущем уровне успеваемости каждого ученика, а также оценивать общие результаты по классу и предмету.
    4. Обеспечение безопасности и управления доступом: Разработка системы прав доступа, которая будет ограничивать возможности пользователей в зависимости от их ролей (учитель, администратор). Это необходимо для защиты конфиденциальной информации о студентах и обеспечения целостности данных.
    5. Анализ полученных данных: Проведение анализа успеваемости учеников с использованием созданной базы данных. Это позволит выявить тенденции, проблемы и возможности для улучшения учебного процесса, а также поможет в принятии обоснованных решений по дальнейшему обучению.
    6. Документирование процесса разработки: Подготовка технической и эксплуатационной документации, включая описание структуры базы данных, функционала, а также руководства для пользователей. Это обеспечит удобство в использовании системы и поможет в обучении новых пользователей.
Таким образом, цель работы заключается в создании эффективной базы данных для контроля успеваемости школьников, которая будет способствовать оптимизации процессов управления учебной информацией и повышению качества образования.


#### <a id="tasks">Задачи работы</a>

Для достижения поставленной цели необходимо решить следующие задачи:

1. **Анализировать предметную область контроля успеваемости школьников** Это включает в себя изучение существующих методов учета успеваемости, требований пользователей (учителей, администраторов и родителей) к системе, а также особенностей образовательного процесса. Важно определить, какую информацию необходимо хранить и обрабатывать, а также выявить ключевые проблемы, которые могут быть решены с помощью базы данных.
2. **Проектировать структуру базы данных.** На этом этапе необходимо определить ключевые таблицы, их атрибуты и связи между сущностями. В частности, следует четко определить структуру таблиц. Важно установить правильные типы данных для каждого атрибута и определить, какие ограничения целостности должны быть применены (например, уникальность, проверка значений).
3. **Выбрать и обосновать систему управления базами данных (СУБД)** Необходимо провести анализ различных СУБД (например, MySQL, PostgreSQL, SQLite) с учетом требований проекта, таких как производительность, масштабируемость, простота использования и поддержка необходимых функций. На основании этого анализа следует выбрать наиболее подходящую СУБД и обосновать выбор.
4. **Реализовать структуру базы данных на выбранной СУБД** Это включает в себя написание SQL-запросов для создания таблиц, определения их атрибутов и установления связей между ними. Важно также учесть создание индексов для оптимизации запросов и обеспечения быстрого доступа к данным.
5. **Заполнить базу данных тестовыми данными** Для проверки работоспособности и корректности структуры базы данных необходимо подготовить и вставить тестовые данные в каждую из таблиц. Это позволит убедиться в правильности работы системы и обеспечит возможность тестирования различных функций и запросов.
6. **Разработать и протестировать приложение с использованием Python** для получения необходимых данных. Это включает в себя создание запросов для выборки оценок учеников, получения статистики по успеваемости, а также генерации отчетов для учителей. Важно протестировать эти запросы на корректность и эффективность, убедившись, что они возвращают ожидаемые результаты.
7. **Осуществить тестирование базы данных** На этом этапе необходимо провести комплексное тестирование, чтобы проверить корректность выполнения всех операций, целостность данных и функциональность запросов. Это может включать в себя как ручное тестирование, так и автоматизированные тесты для проверки различных сценариев использования базы данных.
8. **Сформулировать выводы и предложения** по дальнейшему развитию и расширению функционала базы данных. На основе полученных результатов тестирования и анализа работы системы следует сделать выводы о её эффективности, выявить возможные недостатки и предложить пути их устранения. Это может включать в себя рекомендации по улучшению интерфейса, добавлению новых функций или оптимизации структуры базы данных.

Эти задачи направлены на создание эффективного инструмента, который позволит образовательным учреждениям упорядочить данные о успеваемости школьников, автоматизировать ключевые процессы учета и анализа, а также облегчить доступ к информации для всех заинтересованных пользователей.

### <a id="main">Основная часть</a>

#### <a id="analysis">Анализ предметной области. Постановка задачи</a>

1. **Описание предметной области и функции решаемых задач**
    - **Предметная область** данной работы - управление успеваемостью школьников в образовательных учреждениях. Система направлена на автоматизацию процессов учета успеваемости, что позволит учителям эффективно отслеживать достижения учащихся, анализировать их результаты и собственно редактировать значения. Основной целью автоматизации является упрощение работы с данными, надежное хранение данных, повышение прозрачности учебного процесса и улучшение качества образования.
    - **Функции решаемых задач:**
        - **Хранение информации о классах:** Ведение базы данных, содержащей информацию о каждом классе (номер, буква, год начала обучения). Это позволит администраторам легко управлять данными о классах и отслеживать их изменения.
        - **Учет учеников:** Сохранение данных о каждом ученике, включая имя, фамилию, отчество, дату рождения и класс. Это обеспечит возможность быстрого доступа к информации о каждом учащемся и его учебной истории.
        - **Ведение оценок:** Запись оценок учеников по каждому предмету с указанием даты урока, номера урока и учителя. Это позволит формировать полную картину успеваемости каждого ученика и анализировать динамику его успехов.
        - **Обеспечение доступа к информации:** Создание интуитивно понятного интерфейса, который позволит учителям легко находить нужные данные о классах, учениках и их оценках.
        - **Генерация отчетов:** Автоматическое создание отчетов на основе данных, содержащихся в базе, таких как списки учеников с их оценками, статистика успеваемости по классам и предметам, а также информация об учителях их предметах и классах, которые они ведут.
2. **Перечень входных данных.** Для эффективной работы системы необходимы следующие входные данные:
    - **Данные о классах:**
        - Идентификатор класса (ID).
        - Номер класса.
        - Буква класса.
        - Год начала обучения.
    - **Данные о учителях:**
        - Идентификатор учителя (ID).
        - Имя, фамилия и отчество учителя.
        - Предметы, которые ведет учитель.
        - Классы, которым преподает учитель.
        - Логин и пароль, для авторизации.
    - **Данные о учениках:**
        - Идентификатор ученика (ID).
        - Имя, фамилия и отчество ученика.
        - Дата рождения.
        - Класс, к которому принадлежит ученик.
        - Логин и пароль, для авторизации.
        - История, в каких классах ученик учился.
    - **Данные о предметах:**
        - Идентификатор предмета (ID).
        - Название предмета.
    - **Данные о администраторах:**
        - Идентификатор предмета (ID).
        - Логин и пароль, для авторизации.
    - **Данные о оценках:**
        - Идентификатор оценки (ID).
        - Идентификатор ученика.
        - Идентификатор предмета.
        - Идентификатор класса.
        - Идентификатор учителя.
        - Оценка (в диапазоне от 2 до 5).
        - Номер урока.
        - Дата урока.
        - Дата создания оценки.
        - Дата изменения оценки (при необходимости).
 сумма).
3. **Перечень выходных данных.** На основе входных данных система должна предоставить следующие выходные данные:
    - **Отчёт по успеваемости учеников:**
        - Список оценок по предмету у ученика за определенный период.
        - Итоговые оценки за учебные года.
        - Табель оценок по классу.
        - Табель итоговых оценок по классу.
    - **Статистика успеваемости по классам и предметам:**
        - Сравнительный анализ успеваемости класса (изменение оценок за определённый период).
    - **Информация об учителях и их предметах:**
        - Список учителей с указанием предметов и классов которые они ведут.
4. **Ограничения предметной области.** При работе с базой данных могут возникнуть следующие ограничения:
    - **Ограничение по объёму данных:** Увеличение количества учеников, классов и оценок может негативно сказаться на производительности системы. Необходимо учитывать возможность оптимизации базы данных, включая использование индексации и других методов для повышения скорости обработки запросов.
    - **Ограничение по доступу:** Личная информация о учениках и их оценках должна быть защищена от несанкционированного доступа. Это требует реализации надежных механизмов авторизации, чтобы только уполномоченные лица могли получать доступ к конфиденциальной информации.
    - **Ограничение по обновлению данных:** Для предотвращения потери данных необходимо разработать систему резервного копирования. Регулярные бэкапы помогут избежать потерь информации в случае технических сбоев или ошибок пользователей.
5. **Взаимодействие с другими программами.** Система управления успеваемостью может взаимодействовать с различными образовательными и административными системами для расширения функциональности:
    - **Система управления учебным процессом** Интеграция с существующими системами управления учебным процессом позволит автоматизировать обмен данными о расписании уроков, классах и учителях.
    - **Портал для родителей:** Создание веб-портала, где родители смогут отслеживать успеваемость своих детей, получать уведомления о новых оценках и взаимодействовать с учителями.
    - **Система аналитики:** Интеграция с аналитическими платформами (например, Power BI или Google Data Studio) для визуализации данных и создания отчетов, что поможет в анализе успеваемости и выявлении проблемных областей.
    - **Электронный дневник:** Взаимодействие с электронными дневниками, которые позволяют учителям и ученикам отслеживать успеваемость и посещаемость в реальном времени.

#### <a id="infological_model">Инфологическая (концептуальная) модель базы данных</a>

Концептуальная модель базы данных описывает структуру данных, которая будет храниться и обрабатываться в базе, без привязки к конкретной системе управления базами данных (СУБД). В рамках этой модели выделяются ключевые информационные объекты, атрибуты этих объектов, связи между ними, а также мощности отношений, которые определяют тип связей между сущностями.

1. **Выделение информационных объектов.** На основе анализа бизнес-процессов торговой организации выделяются следующие информационные объекты:
    - **Классы** - информация о всех классах за всю историю учебного заведения.
    - **Учителя** - данные о учителях.
    - **Администраторы** - данные об администраторах.
    - **Ученики** - данные о учениках.
    - **Предметы** - информация о том, какие предметы преподаются в учебном заведении.
    - **Оценки** - история всех оценок, за все время.
2. **Определение атрибутов объектов.** Каждая из выделенных сущностей имеют свои уникальные атрибуты, которые описывают их свойства.
    - **Администраторы:**
        - admin_id (Уникальный идентификатор администратора).
        - login.
        - password.
    - **Классы:**
        - class_id (Уникальный идентификатор класса).
        - class_number (Номер класса).
        - class_letter (Буква класса).
        - start_year (Год начала обучения).
    - **Учителя:**
        - teacher_id (Уникальный Идентификатор учителя).
        - first_name (Имя учителя).
	- last_name (Фамилия учителя).
	- second_name (Отчество учителя).
        - Предметы, которые ведет учитель.
        - Классы, которые ведет учитель.
        - login.
        - password.
    - **Ученики:**
        - student_id (Уникальный идентификатор ученика).
        - first_name (Имя ученика).
        - last_name (Фамилия ученика).
	- second_name (Отчество ученика).
        - date_of_birth (Дата рождения).
        - class_id (Класс, к которому принадлежит ученик).
        - history_classes (История классов в которых учился ученик).
        - login.
        - password.
    - **Предметы:**
        - subject_id (Уникальный идентификатор предмета).
        - subject_name (Название предмета).
    - **Оценки:**
        - grade_id (Идентификатор оценки (ID).
        - student_id (Идентификатор ученика).
        - subject_id (Идентификатор предмета).
        - class_id (Идентификатор класса).
        - teacher_id (Идентификатор учителя).
        - grade (Оценка, в диапазоне от 2 до 5).
        - number_lesson (Номер урока).
        - date_lesson (Дата урока).
        - create_date (Дата создания оценки).
        - update_date (Дата изменения оценки).
3. **Определение отношений и мощности отношений между объектами.** В данной базе данных для контроля успеваемости школьников выделены следующие сущности и их взаимосвязи:
- **Класс — Ученик:**
    - **Связь:** один ко многим.
    - **Описание:** Каждый класс может включать множество учеников, однако каждый ученик может быть зачислен только в один конкретный класс. Это позволяет организовать учебный процесс и контролировать успеваемость в рамках определённой группы учащихся.

- **Учитель - Учитель_Предмет:**
    - **Связь:** один ко многим.
    - **Описание:** Один учитель может преподавать несколько предметов, но каждый предмет может быть преподаваться только одним учителем в рамках данного отношения. Это отношение позволяет гибко распределять нагрузки между учителями и эффективно управлять расписанием.

- **Предмет - Учитель_Предмет:**
    - **Связь:** один ко многим.
    - **Описание:** Каждый предмет может быть связан с несколькими учителями, если, например, в разных классах его ведут разные преподаватели. Однако каждый конкретный учитель может преподавать данный предмет только в рамках своей учебной нагрузки.

- **Ученик - Оценка:**
    - **Связь:** один ко многим.
    - **Описание:** Один ученик может получать множество оценок по различным предметам на протяжении учебного года. Каждая оценка, в свою очередь, относится только к одному ученику, что позволяет отслеживать его успеваемость и динамику обучения.

- **Предмет - Оценка:**
    - **Связь:** один ко многим.
    - **Описание:** Каждый предмет может иметь множество оценок, выставленных ученикам. Каждая оценка привязана к конкретному предмету, что позволяет анализировать успеваемость по каждому предмету в отдельности.

- **Учитель - Оценка:**
    - **Связь:** один ко многим.
    - **Описание:** Один учитель может выставлять множество оценок своим ученикам, но каждая оценка выставляется только одним учителем. Это отношение обеспечивает прозрачность и ответственность в процессе оценки успеваемости.

- **Класс - Оценка:**
    - **Связь:** один ко многим.
    - **Описание:** Каждый класс может иметь множество оценок, выставленных его ученикам. Каждая оценка относится к конкретному классу, что позволяет анализировать успеваемость всего класса в целом.

- **Оценка - Урок:**
    - **Связь:** один ко многим.
    - **Описание:** Каждая оценка относится к конкретному уроку, но один урок может иметь множество оценок, выставленных различным ученикам. Это позволяет детально отслеживать успеваемость на уровне отдельных занятий.

Каждое из этих отношений помогает структурировать данные в базе и обеспечивает возможность глубокого анализа успеваемости школьников, а также управления учебным процессом.

4. **Построение концептуальной модели.** На основе выделенных сущностей, их атрибутов и связей между ними можно построить концептуальную ER-диаграмму для базы данных, предназначенной для контроля успеваемости школьников.

![Screenshot_7](https://github.com/user-attachments/assets/f81b4a28-c905-4ced-b28b-c26572c3caa7)

Эта концептуальная модель позволяет наглядно представить структуру базы данных, а также связи между различными сущностями, что упрощает дальнейшее проектирование и реализацию системы контроля успеваемости школьников.

#### <a id="logical_structure">Логическая структура базы данных</a>

Логическая структура базы данных представляет собой детализированное описание таблиц, их атрибутов, типов данных, а также ключевых ограничений и правил целостности. На основе концептуальной модели можно построить логическую структуру, которая будет готова для реализации в системе управления базами данных (СУБД).

В данной структуре будут определены следующие таблицы: **Администраторы**, **Классы**, **Учителя**, **Ученики**, **Предметы**, **Учитель_Предмет**, **Учитель_Класс**, **Оценки**, а также связи между ними.

#### Определение таблиц и их атрибутов

1. **Таблица "Администраторы"**
    - **admin_id** (Primary Key) - уникальный идентификатор администратора (целое число).
    - **login** - логин администратора (строка).
    - **password** - пароль администратора (строка).

    **Типы данных:**
    - admin_id - SERIAL.
    - login - VARCHAR(50).
    - password - VARCHAR(50).

    **Ограничения:**
    - admin_id является уникальным и не может быть NULL.
    - login является уникальным и не может быть NULL.
    - password не может быть NULL.

2. **Таблица "Классы"**
    - **class_id** (Primary Key) - уникальный идентификатор класса (целое число).
    - **class_number** - номер класса (целое число).
    - **class_letter** - буква класса (строка).
    - **start_year** - год начала обучения (дата).

    **Типы данных:**
    - class_id - SERIAL.
    - class_number - INT.
    - class_letter - VARCHAR(5).
    - start_year - DATE.

    **Ограничения:**
    - class_id является уникальным и не может быть NULL.
    - class_number не может быть NULL.
    - class_letter не может быть NULL.
    - start_year не может быть NULL.

3. **Таблица "Учителя"**
    - **teacher_id** (Primary Key) - уникальный идентификатор учителя (целое число).
    - **first_name** - имя учителя (строка).
    - **last_name** - фамилия учителя (строка).
    - **second_name** - отчество учителя (строка).
    - **login** - логин учителя (строка).
    - **password** - пароль учителя (строка).
    - **deleted** - статус удаления (логическое значение).

    **Типы данных:**
    - teacher_id - SERIAL.
    - first_name - VARCHAR(50).
    - last_name - VARCHAR(50).
    - second_name - VARCHAR(50).
    - login - VARCHAR(50).
    - password - VARCHAR(50).
    - deleted - BOOLEAN.

    **Ограничения:**
    - teacher_id является уникальным и не может быть NULL.
    - login является уникальным и не может быть NULL.
    - password не может быть NULL.

4. **Таблица "Ученики"**
    - **student_id** (Primary Key) - уникальный идентификатор ученика (целое число).
    - **first_name** - имя ученика (строка).
    - **last_name** - фамилия ученика (строка).
    - **second_name** - отчество ученика (строка).
    - **date_of_birth** - дата рождения ученика (дата).
    - **class_id** (Foreign Key) - ссылка на таблицу **Классы** (целое число).
    - **history_classes** - история классов (строка).
    - **login** - логин ученика (строка).
    - **password** - пароль ученика (строка).

    **Типы данных:**
    - student_id - SERIAL.
    - first_name - VARCHAR(50).
    - last_name - VARCHAR(50).
    - second_name - VARCHAR(50).
    - date_of_birth - DATE.
    - class_id - INT.
    - history_classes - VARCHAR(8000).
    - login - VARCHAR(50).
    - password - VARCHAR(50).

    **Ограничения:**
    - student_id является уникальным и не может быть NULL.
    - class_id является внешним ключом, который ссылается на таблицу **Классы**.
    - date_of_birth должна быть меньше текущей даты.

5. **Таблица "Предметы"**
    - **subject_id** (Primary Key) - уникальный идентификатор предмета (целое число).
    - **subject_name** - название предмета (строка).

    **Типы данных:**
    - subject_id - SERIAL.
    - subject_name - VARCHAR(50).

    **Ограничения:**
    - subject_id является уникальным и не может быть NULL.
    - subject_name не может быть NULL.

6. **Таблица "Учитель_Предмет"**
    - **teacher_id** (Foreign Key) - ссылка на таблицу **Учителя** (целое число).
    - **subject_id** (Foreign Key) - ссылка на таблицу **Предметы** (целое число).

    **Типы данных:**
    - teacher_id - INT.
    - subject_id - INT.

    **Ограничения:**
    - teacher_id и subject_id вместе образуют составной первичный ключ и не могут быть NULL.

7. **Таблица "Учитель_Класс"**
    - **teacher_id** (Foreign Key) - ссылка на таблицу **Учителя** (целое число).
    - **class_id** (Foreign Key) - ссылка на таблицу **Классы** (целое число).

    **Типы данных:**
    - teacher_id - INT.
    - class_id - INT.

    **Ограничения:**
    - teacher_id и class_id вместе образуют составной первичный ключ и не могут быть NULL.

8. **Таблица "Оценки"**
    - **grade_id** (Primary Key) - уникальный идентификатор оценки (целое число).
    - **student_id** (Foreign Key) - ссылка на таблицу **Ученики** (целое число).
    - **class_id** (Foreign Key) - ссылка на таблицу **Классы** (целое число).
    - **subject_id** (Foreign Key) - ссылка на таблицу **Предметы** (целое число).
    - **teacher_id** (Foreign Key) - ссылка на таблицу **Учителя** (целое число).
    - **grade** - оценка (целое число, допустимые значения: 2, 3, 4, 5).
    - **number_lesson** - номер урока (целое число).
    - **date_lesson** - дата урока (дата).
    - **create_date** - дата создания записи (дата).
    - **update_date** - дата обновления записи (дата).

    **Типы данных:**
    - grade_id - SERIAL.
    - student_id - INT.
    - class_id - INT.
    - subject_id - INT.
    - teacher_id - INT.
    - grade - INT.
    - number_lesson - INT.
    - date_lesson - DATE.
    - create_date - DATE.
    - update_date - DATE.

    **Ограничения:**
    - grade_id является уникальным и не может быть NULL.
    - student_id, class_id, subject_id и teacher_id являются внешними ключами, которые ссылаются на соответствующие таблицы.
    - grade должен быть в диапазоне от 2 до 5.


**Нормализация базы данных**

На данном этапе структура базы данных приведена к третьей нормальной форме (3NF), что позволяет:

- Устранить избыточность данных.
- Избежать аномалий при добавлении, изменении и удалении данных.
- Обеспечить более эффективное использование памяти и более быструю обработку запросов.


### <a id="physical_structure">Физическая структура базы данных</a>

Физическая структура базы данных отвечает за реальное хранение данных на физическом уровне, определяет способы хранения и работы с данными, обеспечивая при этом их целостность, доступность и производительность системы. На этом этапе важно учитывать оптимизацию производительности запросов, объёмы данных и ограничения, связанные с физическим хранением данных в выбранной СУБД. В данной курсовой работе предполагается использование реляционной СУБД (PostgreSQL), так как она предоставляет оптимальные средства для управления табличными данными и поддерживает сложные связи между данными, что необходимо для образовательной организации.

Физическая структура проектируется таким образом, чтобы система максимально эффективно обрабатывала данные, предоставляя пользователю доступ к нужной информации с минимальной задержкой. Это достигается с помощью выбора правильных типов данных, индексов, механизмов хранения и настройки параметров, обеспечивающих производительность и надежность.

1. **Выбор типов данных**

Правильный выбор типов данных для полей таблиц — один из ключевых аспектов проектирования физической структуры базы данных, так как это позволяет экономить ресурсы и повышать производительность.

**Рассмотрим выбор типов данных для каждой таблицы:**

- **SERIAL** — используется для автоинкрементных значений, таких как идентификаторы записей. Это подходит для полей, которые используются как ключи и часто участвуют в соединениях и фильтрации данных.
- **INT** — используется для целочисленных значений, занимает фиксированный объем памяти и обеспечивает эффективное индексирование, что важно для первичных и внешних ключей. Это подходит для полей, которые используются как ключи и часто участвуют в соединениях и фильтрации данных.
- **VARCHAR(n)** — применяется для хранения текстовых данных переменной длины, таких как имена, названия и описания. Этот тип позволяет оптимально расходовать память, так как фактически занимает объем, соответствующий реальной длине строки.
- **DATE** — этот тип данных используется для хранения дат. Он позволяет хранить значения в формате даты (год, месяц, день) и обеспечивает удобные функции для работы с датами, такие как сравнение и вычисление разницы между датами.
- **BOOLEAN** — используется для хранения логических значений, которые могут принимать два состояния: TRUE (истина) или FALSE (ложь). Он часто используется для представления бинарных состояний, таких как наличие или отсутствие, активный или неактивный статус. Например, поле deleted в таблице Teachers указывает, был ли учитель удален.

Тип данных влияет на объем занимаемой памяти и производительность базы данных, так как данные записываются и извлекаются в зависимости от того, какой тип используется.

**Пример SQL-кода с применением типов данных для таблицы "Оценки":**

```
CREATE TABLE Grades (
    grade_id SERIAL PRIMARY KEY,
    student_id INT,
    class_id INT,
    subject_id INT,
    teacher_id INT,
    grade INT CHECK (grade IN (2, 3, 4, 5)),
    number_lesson INT NOT NULL,
    date_lesson DATE NOT NULL,
    create_date DATE NOT NULL,
    update_date DATE default null,
    FOREIGN KEY (student_id) REFERENCES Students(student_id),
    FOREIGN KEY (subject_id) REFERENCES Subjects(subject_id),
    FOREIGN KEY (teacher_id) REFERENCES Teachers(teacher_id),
    FOREIGN KEY (class_id) REFERENCES Classes(class_id)
);
```

2. **Оптимизация индексов**

Индексы являются ключевым элементом в оптимизации базы данных, так как они позволяют ускорить доступ к данным и облегчают выполнение запросов, таких как поиск, фильтрация и сортировка. Индексы создаются для полей, которые часто участвуют в поисковых запросах и соединениях таблиц.

- **Первичные ключи** автоматически индексируются, так как они служат для уникальной идентификации каждой записи. Это гарантирует быстрое выполнение операций поиска и обновления записей.
- **Внешние ключи** (например, student_id, class_id, subject_id, teacher_id) также индексируются, чтобы ускорить выполнение соединений между таблицами. Внешние ключи позволяют поддерживать целостность данных, предотвращая создание записей, не соответствующих связанным данным.
- **Дополнительные индексы** — могут быть добавлены для часто запрашиваемых полей, например, для поля lesson_date в таблице Оценки, если предполагается, что пользователи часто будут искать оценки по дате.

**Создание индексов, используемых в условиях WHERE:**

```
CREATE INDEX idx_students_login ON Students (login);
CREATE INDEX idx_teachers_login ON Teachers (login);
CREATE INDEX idx_classes_class_number_letter ON Classes (class_number, class_letter);
CREATE INDEX idx_grades_student_id ON Grades (student_id);
CREATE INDEX idx_grades_class_id ON Grades (class_id);
CREATE INDEX idx_grades_subject_id ON Grades (subject_id);
CREATE INDEX idx_grades_teacher_id ON Grades (teacher_id);
```

**Создание индексов, используемых в условиях JOIN:**

```
CREATE INDEX idx_teacher_classes_teacher_id ON Teacher_Classes (teacher_id);
CREATE INDEX idx_teacher_subject_teacher_id ON Teacher_Subject (teacher_id);
```

**Создание индексов, используемых в условиях ORDER BY и GROUP BY:**

```
CREATE INDEX idx_grades_date_lesson ON Grades (date_lesson);
CREATE INDEX idx_grades_student_class_subject ON Grades (student_id, class_id, subject_id);
```

**Преимущества индексов:**

- Ускоряют поиск и сортировку.
- Повышают производительность запросов с условиями фильтрации.
- Уменьшают время выполнения операций соединения.

**Недостаток индексов:**
- Индексы занимают место и могут замедлить операции вставки, обновления и удаления, так как индексы также нужно обновлять.

3. **Таблицы и кластеризация данных**

Кластеризация позволяет физически упорядочивать записи на диске по значению индекса, что может существенно ускорить выполнение запросов, в которых данные фильтруются и сортируются по определенному столбцу. Например, таблицу Оценки можно упорядочить по lesson_date, чтобы данные о занятиях находились физически рядом. Это улучшает производительность запросов, касающихся конкретных уроков, так как чтение данных с диска выполняется быстрее.

4. **Механизм хранения и параметры оптимизации**

PostgreSQL использует механизм хранения данных, поддерживающий многоверсионность (MVCC, Multiversion Concurrency Control), что позволяет эффективно управлять транзакциями и конкурентным доступом к данным. В отличие от MySQL, PostgreSQL не требует явного указания механизма хранения при создании таблиц, так как все таблицы автоматически используют встроенный механизм. Этот механизм обеспечивает высокий уровень надежности, особенно для данных, подверженных частым изменениям, и поддерживает управление транзакциями, что критично для точности и согласованности данных.

**Преимущества MVCC в PostgreSQL для базы данных торговой организации:**

- **Поддержка транзакций** — гарантирует согласованность данных, например, при записи продаж и их составных частей. Каждая транзакция выполняется как отдельная операция, и в случае неудачи все изменения отменяются.
- **Конкурентный доступ** — PostgreSQL позволяет нескольким пользователям одновременно работать с данными, обеспечивая при этом изоляцию транзакций, что делает его особенно подходящим для высоконагруженных приложений, где требуется частое обновление данных.
- **Гибкое управление блокировками** — позволяет предотвращать конфликты между транзакциями и поддерживает высокую производительность.

**Особенности PostgreSQL при создании таблиц:**

- **Тип SERIAL** — используется для создания автоинкрементных первичных ключей. В PostgreSQL SERIAL автоматически создает последовательность и обеспечивает уникальные значения для каждого нового элемента, что упрощает настройку первичных ключей.
- **CHECK-ограничения** — PostgreSQL поддерживает гибкие ограничения, которые помогают контролировать значения в полях. Например, ограничения на поле **Оценка** гарантирует, что значения будут только 2, 3, 4 или 5.

5. **Политики управления целостностью данных**

PostgreSQL предоставляет богатый функционал для поддержания целостности данных с использованием различных ограничений и ключей. Эти механизмы помогают гарантировать, что база данных всегда находится в согласованном состоянии.

**Основные элементы для управления целостностью:**

- **Первичные ключи (PRIMARY KEY)** — используются для уникальной идентификации записей в таблицах. В PostgreSQL первичные ключи создаются с использованием уникального индекса и автоматически проверяют уникальность значения.
- **Внешние ключи (FOREIGN KEY)** — обеспечивают целостность ссылочной структуры между таблицами. Внешние ключи используются, чтобы установить зависимость между записями. Например, в таблице Оценки внешний ключ student_id гарантирует, что ученик будет существовать в таблице Ученики.
- **Ограничения NOT NULL** — применяются к полям, значения в которых обязательно должны быть указаны. Поля, такие как grade и lesson_date, не могут быть пустыми, так как эти данные являются обязательными для бизнес-процессов.
- **CHECK-ограничения** — применяются для контроля значений полей в соответствии с установленными правилами. Например, в поле grade вводятся только значения 2, 3, 4 или 5, что соответствует оценочной системе.

```
CREATE TABLE Ученики (
    student_id SERIAL PRIMARY KEY,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    date_of_birth DATE NOT NULL,
    class_id INT NOT NULL,
    CHECK (date_of_birth < CURRENT_DATE),
    FOREIGN KEY (class_id) REFERENCES Классы(class_id)
);
```

В этом примере используется регулярное выражение для проверки, что дата рождения должна быть раньше нынешней даты.

**Другие механизмы управления целостностью:**

- **Триггеры** — PostgreSQL поддерживает триггеры, которые позволяют выполнять дополнительные проверки и операции при добавлении, обновлении или удалении записей. Триггеры могут использоваться для автоматической записи истории изменений или для сложных проверок целостности, когда стандартных ограничений недостаточно.
- **Индексы** — PostgreSQL автоматически создает индексы для полей, которые заданы как первичные ключи или уникальные. Это улучшает производительность запросов, так как индекс ускоряет поиск и доступ к данным.
- **Управление транзакциями** — PostgreSQL поддерживает уровни изоляции транзакций, которые позволяют определять правила работы с параллельными запросами.

Таким образом, механизмы управления целостностью в PostgreSQL обеспечивают надежную работу базы данных, поддерживая высокую степень согласованности и производительности.

6. **Параметры хранения и резервное копирование**

Для обеспечения надежности базы данных образовательной организации и защиты от потерь данных, в PostgreSQL необходимо организовать систему резервного копирования и продумать параметры хранения. PostgreSQL предлагает несколько методов резервного копирования и восстановления данных, а также настройки, которые влияют на производительность и безопасность системы.

**Резервное копирование**

PostgreSQL поддерживает два основных типа резервного копирования:

- **Логическое резервное копирование** — выполняется с помощью утилиты pg_dump. Этот метод позволяет копировать структуру и данные одной или нескольких баз данных. Логическое копирование используется в ситуациях, когда требуется гибкость, например, для восстановления на другой версии PostgreSQL или для миграции данных.

Пример использования pg_dump для создания резервной копии:

```
pg_dump -U username -F c -b -v -f "backup_filename.backup" database_name
```

Этот скрипт сохраняет базу данных в формате архивного файла, который затем можно будет использовать для восстановления.

- **Физическое резервное копирование** — выполняется путем копирования файлов данных на уровне файловой системы. PostgreSQL предоставляет инструмент pg_basebackup, который выполняет копирование всех файлов базы данных и создаёт полную копию в заданном каталоге.

Пример использования pg_basebackup:

```
pg_basebackup -U postgres -D /path/to/backup -Ft -z -P
```

Физическое резервное копирование особенно полезно для больших баз данных и высоконагруженных систем, так как оно позволяет быстрее восстанавливать данные и поддерживать согласованность на уровне файлов.

7. **SQL-код создания таблиц с физической структурой для PostgreSQL**

В этом разделе приводится полный пример SQL-кода для создания таблиц, описанных в предыдущих разделах. Каждая таблица строится с учетом требований физической структуры базы данных и с использованием всех механизмов PostgreSQL для оптимизации, поддержки целостности и обеспечения надежности данных.

```
-- Создание таблицы Администраторы
CREATE TABLE Admins (
    admin_id SERIAL PRIMARY KEY,
    login VARCHAR(50) UNIQUE NOT NULL,
    password VARCHAR(50) NOT NULL
);


-- Создание таблицы Классы
CREATE TABLE Classes (
    class_id SERIAL PRIMARY KEY,
    class_number INT NOT NULL,
    class_letter VARCHAR(5) NOT null,
    start_year DATE NOT NULL
);

-- Создание таблицы Учителя
CREATE TABLE Teachers (
    teacher_id SERIAL PRIMARY KEY,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    second_name VARCHAR(50) NOT null,
    login VARCHAR(50) UNIQUE NOT NULL,
  password VARCHAR(50) NOT NULL,
  deleted BOOLEAN NOT NULL DEFAULT FALSE
);

-- Создание таблицы Ученики
CREATE TABLE Students (
    student_id SERIAL PRIMARY KEY,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    second_name VARCHAR(50) NOT NULL,
    date_of_birth DATE NOT NULL,
    class_id INT,
    history_classes VARCHAR(8000) DEFAULT NULL,
    login VARCHAR(50) UNIQUE NOT NULL,
  password VARCHAR(50) NOT NULL,
    CHECK (date_of_birth < CURRENT_DATE),
    FOREIGN KEY (class_id) REFERENCES Classes(class_id)
);

-- Создание таблицы Предметы
CREATE TABLE Subjects (
    subject_id SERIAL PRIMARY KEY,
    subject_name VARCHAR(50) NOT NULL
);

-- Создание таблицы Учитель_Предмет
CREATE TABLE Teacher_Subject (
    teacher_id INT,
    subject_id INT,
    PRIMARY KEY (teacher_id, subject_id),
    FOREIGN KEY (teacher_id) REFERENCES Teachers(teacher_id),
    FOREIGN KEY (subject_id) REFERENCES Subjects(subject_id)
);

-- Создание таблицы Учитель_Класс
CREATE TABLE Teacher_Classes (
    teacher_id INT,
    class_id INT,
    PRIMARY KEY (teacher_id, class_id),
    FOREIGN KEY (teacher_id) REFERENCES Teachers(teacher_id),
    FOREIGN KEY (class_id) REFERENCES Classes(class_id)
);


-- Создание таблицы Оценки
CREATE TABLE Grades (
    grade_id SERIAL PRIMARY KEY,
    student_id INT,
    class_id INT,
    subject_id INT,
    teacher_id INT,
    grade INT CHECK (grade IN (2, 3, 4, 5)),
    number_lesson INT NOT NULL,
    date_lesson DATE NOT NULL,
    create_date DATE NOT NULL,
    update_date DATE default null,
    FOREIGN KEY (student_id) REFERENCES Students(student_id),
    FOREIGN KEY (subject_id) REFERENCES Subjects(subject_id),
    FOREIGN KEY (teacher_id) REFERENCES Teachers(teacher_id),
    FOREIGN KEY (class_id) REFERENCES Classes(class_id)
);


-- Индексы для оптимизации запросов
CREATE INDEX idx_students_login ON Students (login);
CREATE INDEX idx_teachers_login ON Teachers (login);
CREATE INDEX idx_classes_class_number_letter ON Classes (class_number, class_letter);
CREATE INDEX idx_grades_student_id ON Grades (student_id);
CREATE INDEX idx_grades_class_id ON Grades (class_id);
CREATE INDEX idx_grades_subject_id ON Grades (subject_id);
CREATE INDEX idx_grades_teacher_id ON Grades (teacher_id);
CREATE INDEX idx_teacher_classes_teacher_id ON Teacher_Classes (teacher_id);
CREATE INDEX idx_teacher_subject_teacher_id ON Teacher_Subject (teacher_id);
CREATE INDEX idx_grades_date_lesson ON Grades (date_lesson);
CREATE INDEX idx_grades_student_class_subject ON Grades (student_id, class_id, subject_id);
```

**Описание и обоснование SQL-кода**

- **Создание таблиц:** Каждая таблица создается с использованием типа SERIAL для первичного ключа, который обеспечивает автоинкремент и уникальность записи. Поля, содержащие важные текстовые данные, используются с типом VARCHAR, а для целочисленных значений и дат применяется тип INT и DATE соответственно.
- **Ограничения целостности:** В таблицах установлены внешние ключи для обеспечения ссылочной целостности. Например, class_id в таблице Students ссылается на таблицу Classes, что гарантирует, что каждый ученик будет принадлежать к существующему классу.
- **Индексы:** Добавлены индексы для полей, которые часто участвуют в запросах.
- **CHECK-ограничения:** Дополнительные ограничения установлены на такие поля, как grade, чтобы защитить базу данных от некорректных значений и обеспечить соответствие данных бизнес-логике.

Этот SQL-код и структура таблиц обеспечивают надежную физическую реализацию базы данных в PostgreSQL для образовательной организации, удовлетворяя всем требованиям по целостности, производительности и масштабируемости.

#### <a id="project_realization">Реализация проекта в среде конкретной СУБД</a>

Этот раздел курсовой работы описывает практическую реализацию базы данных торговой организации в PostgreSQL. Рассматриваются основные этапы — от создания таблиц и запросов до разработки интерфейса и настройки прав доступа, индексов и резервного копирования.

1. **Создание таблиц**


```
-- Создание таблицы Классы
CREATE TABLE Classes (
    class_id SERIAL PRIMARY KEY,
    class_number INT NOT NULL,
    class_letter VARCHAR(5) NOT NULL,
    start_year DATE NOT NULL
);

-- Создание таблицы Учителя
CREATE TABLE Teachers (
    teacher_id SERIAL PRIMARY KEY,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    second_name VARCHAR(50) NOT NULL
);

-- Создание таблицы Ученики
CREATE TABLE Students (
    student_id SERIAL PRIMARY KEY,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    second_name VARCHAR(50) NOT NULL,
    date_of_birth DATE NOT NULL,
    class_id INT,
    CHECK (date_of_birth < CURRENT_DATE),
    FOREIGN KEY (class_id) REFERENCES Classes(class_id)
);

-- Создание таблицы Предметы
CREATE TABLE Subjects (
    subject_id SERIAL PRIMARY KEY,
    subject_name VARCHAR(50) NOT NULL
);

-- Создание таблицы Учитель_Предмет
CREATE TABLE Teacher_Subject (
    teacher_id INT,
    subject_id INT,
    PRIMARY KEY (teacher_id, subject_id),
    FOREIGN KEY (teacher_id) REFERENCES Teachers(teacher_id),
    FOREIGN KEY (subject_id) REFERENCES Subjects(subject_id)
);

-- Создание таблицы Оценки
CREATE TABLE Grades (
    grade_id SERIAL PRIMARY KEY,
    student_id INT,
    class_id INT,
    subject_id INT,
    teacher_id INT,
    grade INT CHECK (grade IN (2, 3, 4, 5)),
    number_lesson INT NOT NULL,
    date_lesson DATE NOT NULL,
    create_date DATE NOT NULL,
    update_date DATE DEFAULT NULL,
    FOREIGN KEY (student_id) REFERENCES Students(student_id),
    FOREIGN KEY (subject_id) REFERENCES Subjects(subject_id),
    FOREIGN KEY (teacher_id) REFERENCES Teachers(teacher_id),
    FOREIGN KEY (class_id) REFERENCES Classes(class_id)
);
```

2. **Создание запросов**

Для удобства работы, реализовано представление для оценок:
```
CREATE OR REPLACE VIEW student_grades AS
SELECT 
    g.grade_id,
    s.student_id,
    s.first_name AS student_first_name,
    s.last_name AS student_last_name,
    sub.subject_name,
    g.grade,
    g.create_date,
    c.class_number,
    c.class_letter,
    g.class_id, 
    g.subject_id  
FROM 
    Grades g
JOIN 
    Students s ON g.student_id = s.student_id
JOIN 
    Subjects sub ON g.subject_id = sub.subject_id
JOIN 
    Classes c ON g.class_id = c.class_id;
```

Запросы для управления базой данных и получения информации помогут обеспечить работу торговой организации. Примеры запросов включают:


- **Функция для добавление оценки:**

```
CREATE OR REPLACE FUNCTION add_grade(
    p_student_id INT,
    p_class_id INT,
    p_subject_id INT,
    p_teacher_id INT,
    p_grade INT,
    p_number_lesson INT,
    p_date_lesson DATE,
    p_create_date DATE
) RETURNS VOID AS $$
BEGIN
    INSERT INTO Grades (student_id, class_id, subject_id, teacher_id, grade, number_lesson, date_lesson, create_date)
    VALUES (p_student_id, p_class_id, p_subject_id, p_teacher_id, p_grade, p_number_lesson, p_date_lesson, p_create_date);
END;
$$ LANGUAGE plpgsql;
```

- **Функция для изменения оценки:**

```
CREATE OR REPLACE FUNCTION update_grade(
    p_grade_id INT,
    p_new_grade INT
) RETURNS VOID AS $$
BEGIN
    UPDATE Grades
    SET grade = p_new_grade, update_date = CURRENT_DATE
    WHERE grade_id = p_grade_id;
END;
$$ LANGUAGE plpgsql;
```

- **Функция для вывода всех оценок у конкретного ученика по конкретному предмету в классе:**

```
CREATE OR REPLACE FUNCTION get_student_grades_by_subject(
    p_student_id INT,
    p_subject_id INT
) RETURNS TABLE (
    grade_id INT,
    grade INT,
    create_date DATE
) AS $$
DECLARE
    v_class_id INT;
BEGIN
    -- Получаем класс студента
    SELECT class_id INTO v_class_id
    FROM Students
    WHERE student_id = p_student_id;

    -- Возвращаем оценки для студента по заданному предмету в его классе
    RETURN QUERY
    SELECT 
        sg.grade_id,
        sg.grade,
        sg.create_date
    FROM 
        student_grades sg
    WHERE 
        sg.student_id = p_student_id AND
        sg.subject_id = p_subject_id AND
        sg.class_id = v_class_id;
END;
$$ LANGUAGE plpgsql;
```

- **Функция для вывода всех оценок у конкретного ученика по конкретному предмету, когда он учился в конкретном классе:**

```
CREATE OR REPLACE FUNCTION get_student_grades_in_class(
    p_student_id INT,
    p_subject_id INT,
    p_class_number INT,
    p_class_letter VARCHAR(5)
) RETURNS TABLE (
    grade_id INT,
    grade INT,
    create_date DATE
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        sg.grade_id,
        sg.grade,
        sg.create_date
    FROM 
        student_grades sg
    JOIN 
        Classes c ON sg.class_number = c.class_number AND sg.class_letter = c.class_letter
    WHERE 
        sg.student_id = p_student_id AND
        sg.subject_id = p_subject_id AND
        c.class_number = p_class_number AND
        c.class_letter = p_class_letter;
END;
$$ LANGUAGE plpgsql;
```

3. **Разработка интерфейса**

Интерфейс для взаимодействия с базой данных можно создать с использованием веб-технологий (например, HTML и JavaScript) или инструментов построения интерфейсов в Python, таких как tkinter. **Основные функции интерфейса должны включать:**

- **Отображение товаров, клиентов и продаж** — списки товаров по категориям, история покупок клиента и т.д.
- **Добавление и обновление данных** — формы для добавления новых клиентов, товаров и регистрации продаж.
- **Фильтрация и поиск** — функционал для поиска по товарам, поставщикам и клиентам.

Например, на языке Python и tkinter можно создать простую форму для регистрации новой продажи, включая выбор клиента и товаров из выпадающего списка.

4. **Назначение прав доступа**

Назначение прав доступа в PostgreSQL выполняется с помощью ролей и команд **GRANT** и **REVOKE**. В целях безопасности база данных торговой организации может иметь следующие роли:

- **Администратор** — имеет полные права на создание, изменение и удаление данных.
- **Менеджер** — может добавлять и обновлять данные о продажах и клиентах, но не имеет прав на удаление записей.
- **Сотрудник** — может только просматривать информацию о товарах и клиентах.

**Пример назначения прав доступа:**

```
-- Создание ролей
CREATE ROLE Администратор WITH LOGIN PASSWORD 'password';
CREATE ROLE Менеджер WITH LOGIN PASSWORD 'password';
CREATE ROLE Сотрудник WITH LOGIN PASSWORD 'password';

-- Назначение прав для каждой роли
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO Администратор;
GRANT SELECT, INSERT, UPDATE ON Товары, Клиенты, Продажи, Состав_продажи TO Менеджер;
GRANT SELECT ON Товары, Клиенты TO Сотрудник;
```

5. **Создание индексов**

Индексы необходимы для повышения скорости обработки запросов, особенно для полей, которые часто используются в фильтрации или сортировке. В PostgreSQL можно создать индексы с помощью команды **CREATE INDEX**.

Примеры создания индексов:

- **Индекс для поиска учеников по их классу. Например, когда необходимо получить всех учеников, принадлежащих к определенному классу:**

```
CREATE INDEX idx_students_class ON Students (class_id);
```

- **Индекс для поиска оценок конкретного ученика. Это полезно, когда необходимо получить все оценки ученика по всем предметам или в определенном классе:**

```
CREATE INDEX idx_grades_student ON Grades (student_id);
```
- **Индекс для поиска оценок по конкретному предмету. Например, когда необходимо получить все оценки для определенного предмета, что может быть полезно для анализа успеваемости по предметам:**

```
CREATE INDEX idx_grades_subject ON Grades (subject_id);
```
- **Индекс для поиска оценок, выставленных конкретным учителем. Это может быть полезно для получения всех оценок, выставленных определенным учителем.:**

```
CREATE INDEX idx_grades_teacher ON Grades (teacher_id);
```
- **Индекс для поиска оценок по классу. Например, когда необходимо получить все оценки для класса, что может быть полезно для анализа успеваемости всего класса.:**

```
CREATE INDEX idx_grades_class ON Grades (class_id);
```
- **Индекс для поиска связи между учителями и предметами. Это позволяет быстро находить, какие предметы ведет конкретный учитель.:**

```
CREATE INDEX idx_teacher_subject ON Teacher_Subject (teacher_id, subject_id);
```

6. **Разработка стратегии резервного копирования базы данных**

Для защиты данных от сбоев и потерь необходимо разработать стратегию регулярного резервного копирования. Для PostgreSQL основными методами являются:

- **Ежедневное логическое резервное копирование с помощью pg_dump** — позволяет создавать бэкап базы данных в формате SQL. Эти резервные копии можно хранить на удаленном сервере или в облаке.

Пример ежедневного резервного копирования:

```
pg_dump -U username -F c -b -v -f "/backups/backup_$(date +\%Y\%m\%d).backup" database_name
```

- **Архивирование WAL-журналов** — для минимизации потерь данных в случае сбоя базы данных необходимо регулярно копировать файлы журнала WAL. Это позволит откатить базу до последнего зафиксированного состояния.

Пример настройки архивации WAL:

```
archive_mode = on
archive_command = 'cp %p /path/to/archive/%f'
```

- **Полное физическое резервное копирование раз в неделю с использованием pg_basebackup** — особенно полезно для больших объемов данных, так как обеспечивает быстрое восстановление базы данных.

Пример команды:

```
pg_basebackup -U postgres -D /path/to/backup -Ft -z -P
```

- **Проверка и тестирование восстановлений** — резервное копирование должно регулярно тестироваться на восстановление, чтобы убедиться в работоспособности резервных копий. Это критически важно для обеспечения постоянной доступности и надежности данных.

Стратегия резервного копирования должна включать хранение нескольких копий данных на случай различных инцидентов, таких как сбой оборудования или ошибка администратора.

[Вернуться к содержанию](#content)

Руководитель работы __________________ И. В. Пунгин

Задание принял к исполнению _______________________________ В. А. Попов
